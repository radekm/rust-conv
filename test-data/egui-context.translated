/// Information given to the backend about when it is time to repaint the ui.
///
/// This is given in the callback set by [`Context::set_request_repaint_callback`].
const RequestRepaintInfo = struct {
/// This is used to specify what viewport that should repaint.
viewport_id: ViewportId,
/// Repaint after this duration. If zero, repaint as soon as possible.
delay: Duration,
/// The current frame number.
///
/// This can be compared to [`Context::frame_nr`] to see if we've already
/// triggered the painting of the next frame.
current_frame_nr: u64,
};
// ----------------------------------------------------------------------------
threadlocal var IMMEDIATE_VIEWPORT_RENDERER : /* Ziggify:  RefCell< Option< Box< ImmediateViewportRendererCallback>>>*/=Default . default (  ) ;
// ----------------------------------------------------------------------------
const WrappedTextureManager = struct {
@"0":/* Ziggify:  Arc< RwLock< epaint :: TextureManager>>*/
};
// BEGIN: impl Default for WrappedTextureManager
fn default()WrappedTextureManager{
var tex_mngr = epaint . textures . TextureManager . default (  ) ;
// Will be filled in later
const font_id = tex_mngr . alloc ( "egui_font_texture" . into (  )  , epaint . FontImage . new ( [0 , 0] )  . into (  )  , Default . default (  )  ,  ) ;
assert_eq !  ( font_id , TextureId . default (  )  ) ;
Self ( Arc . new ( RwLock . new ( tex_mngr )  )  ) 
}

// END: impl Default for WrappedTextureManager
// ----------------------------------------------------------------------------
/// Generic event callback.
const ContextCallback = /* Ziggify:  Arc< dyn Fn( & Context) + Send + Sync>*/;
const NamedContextCallback = struct {
debug_name: *str,
callback: ContextCallback,
};
/// Callbacks that users can register
const Plugins = struct {
on_begin_frame: ArrayList(NamedContextCallback),
on_end_frame: ArrayList(NamedContextCallback),
};
// BEGIN: impl Plugins
fn call(ctx: Context,_cb_name: str,callbacks: []NamedContextCallback)void{
crate . profile_scope !  ( "plugins" , _cb_name ) ;
for (callbacks) |/* Ziggify: NamedContextCallback { debug_name : _name , callback , }*/|{
crate . profile_scope !  ( "plugin" , _name ) ;
 ( callback )  ( ctx ) ;

}

}
fn onBeginFrame(self: Plugins,ctx: Context)void{
Self . call ( ctx , "on_begin_frame" ,  & self . on_begin_frame ) ;

}
fn onEndFrame(self: Plugins,ctx: Context)void{
Self . call ( ctx , "on_end_frame" ,  & self . on_end_frame ) ;

}

// END: impl Plugins
// ----------------------------------------------------------------------------
/// Repaint-logic
// BEGIN: impl ContextImpl
/// This is where we update the repaint logic.
fn beginFrameRepaintLogic(self: *ContextImpl,viewport_id: ViewportId)void{
const viewport = self . viewports . entry ( viewport_id )  . orDefault (  ) ;
std . mem . swap ( &viewport . repaint . prev_causes , &viewport . repaint . causes ,  ) ;
viewport . repaint . causes . clear (  ) ;
viewport . repaint . prev_frame_paint_delay = viewport . repaint . repaint_delay;
if(viewport . repaint . outstanding == 0){
// We are repainting now, so we can wait a while for the next repaint.
viewport . repaint . repaint_delay = Duration . MAX;

}
else{
viewport . repaint . repaint_delay = Duration . ZERO;
viewport . repaint . outstanding -  = 1;
if (/* Ziggify: Some ( callback ) */  & self . request_repaint_callback) {
 ( callback )  ( RequestRepaintInfo {.viewport_id = viewport_id,.delay = Duration . ZERO,.current_frame_nr = viewport . repaint . frame_nr,} ) ;

}

}

}
fn requestRepaint(self: *ContextImpl,viewport_id: ViewportId,cause: RepaintCause)void{
self . requestRepaintAfter ( Duration . ZERO , viewport_id , cause ) ;

}
fn requestRepaintAfter(self: *ContextImpl,delay: Duration,viewport_id: ViewportId,cause: RepaintCause,)void{
const viewport = self . viewports . entry ( viewport_id )  . orDefault (  ) ;
if(delay == Duration . ZERO){
// Each request results in two repaints, just to give some things time to settle.
// This solves some corner-cases of missing repaints on frame-delayed responses.
viewport . repaint . outstanding = 1;

}
else{
// For non-zero delays, we only repaint once, because
// otherwise we would just schedule an immediate repaint _now_,
// which would then clear the delay and repaint again.
// Hovering a tooltip is a good example of a case where we want to repaint after a delay.

}
viewport . repaint . causes . push ( cause ) ;
// We save some CPU time by only calling the callback if we need to.
// If the new delay is greater or equal to the previous lowest,
// it means we have already called the callback, and don't need to do it again.
if(delay < viewport . repaint . repaint_delay){
viewport . repaint . repaint_delay = delay;
if (/* Ziggify: Some ( callback ) */  & self . request_repaint_callback) {
 ( callback )  ( RequestRepaintInfo {.viewport_id = viewport_id,.delay = delay,.current_frame_nr = viewport . repaint . frame_nr,} ) ;

}

}

}
fn requestedImmediateRepaintPrevFrame(self: ContextImpl,viewport_id: ViewportId)bool{
self . viewports . get ( viewport_id )  . mapOr ( false ,  | v | {
v . repaint . requestedImmediateRepaintPrevFrame (  ) 
}
 ) 
}
fn hasRequestedRepaint(self: ContextImpl,viewport_id: ViewportId)bool{
self . viewports . get ( viewport_id )  . mapOr ( false ,  | v | {
0 < v . repaint . outstanding or v . repaint . repaint_delay < Duration . MAX
}
 ) 
}

// END: impl ContextImpl
// ----------------------------------------------------------------------------
/// State stored per viewport
const ViewportState = struct {
/// The type of viewport.
///
/// This will never be [`ViewportClass::Embedded`],
/// since those don't result in real viewports.
class: ViewportClass,
/// The latest delta
builder: ViewportBuilder,
/// The user-code that shows the GUI, used for deferred viewports.
///
/// `None` for immediate viewports.
viewport_ui_cb: ?/* Ziggify:  Arc< DeferredViewportUiCallback>*/,
input: InputState,
/// State that is collected during a frame and then cleared
frame_state: FrameState,
/// Has this viewport been updated this frame?
used: bool,
/// Written to during the frame.
widgets_this_frame: WidgetRects,
/// Read
widgets_prev_frame: WidgetRects,
/// State related to repaint scheduling.
repaint: ViewportRepaintInfo,
// ----------------------
// Updated at the start of the frame:
//
/// Which widgets are under the pointer?
hits: WidgetHits,
/// What widgets are being interacted with this frame?
///
/// Based on the widgets from last frame, and input in this frame.
interact_widgets: InteractionSnapshot,
// ----------------------
// The output of a frame:
//
graphics: GraphicLayers,
// Most of the things in `PlatformOutput` are not actually viewport dependent.
output: PlatformOutput,
commands: ArrayList(ViewportCommand),
};
/// What called [`Context::request_repaint`]?
const RepaintCause = struct {
/// What file had the call that requested the repaint?
file: String,
/// What line number of the the call that requested the repaint?
line: u32,
};
// BEGIN: impl RepaintCause
/// Capture the file and line number of the call site.
pub fn new()RepaintCause{
const caller = Location . caller (  ) ;
RepaintCause {.file = caller . file (  )  . toOwned (  ) ,.line = caller . line (  ) ,}
}

// END: impl RepaintCause
// BEGIN: impl std :: fmt :: Display for RepaintCause
fn fmt(self: RepaintCause,f: */* Ziggify:  std :: fmt :: Formatter< ' _>*/)std.fmt.Result{
write !  ( f , "{}:{}" , self . file , self . line ) 
}

// END: impl std :: fmt :: Display for RepaintCause
/// Per-viewport state related to repaint scheduling.
const ViewportRepaintInfo = struct {
/// Monotonically increasing counter.
frame_nr: u64,
/// The duration which the backend will poll for new events
/// before forcing another egui update, even if there's no new events.
///
/// Also used to suppress multiple calls to the repaint callback during the same frame.
///
/// This is also returned in [`crate::ViewportOutput`].
repaint_delay: Duration,
/// While positive, keep requesting repaints. Decrement at the start of each frame.
outstanding: u8,
/// What caused repaints during this frame?
causes: ArrayList(RepaintCause),
/// What triggered a repaint the previous frame?
/// (i.e: why are we updating now?)
prev_causes: ArrayList(RepaintCause),
/// What was the output of `repaint_delay` on the previous frame?
///
/// If this was zero, we are repainting as quickly as possible
/// (as far as we know).
prev_frame_paint_delay: Duration,
};
// BEGIN: impl Default for ViewportRepaintInfo
fn default()ViewportRepaintInfo{
ViewportRepaintInfo {.frame_nr = 0,.repaint_delay = Duration . MAX,.outstanding = 1,.causes = Default . default (  ) ,.prev_causes = Default . default (  ) ,.prev_frame_paint_delay = Duration . MAX,}
}

// END: impl Default for ViewportRepaintInfo
// BEGIN: impl ViewportRepaintInfo
pub fn requestedImmediateRepaintPrevFrame(self: ViewportRepaintInfo)bool{
self . prev_frame_paint_delay == Duration . ZERO
}

// END: impl ViewportRepaintInfo
// ----------------------------------------------------------------------------
const ContextImpl = struct {
/// Since we could have multiple viewports across multiple monitors with
/// different `pixels_per_point`, we need a `Fonts` instance for each unique
/// `pixels_per_point`.
/// This is because the `Fonts` depend on `pixels_per_point` for the font atlas
/// as well as kerning, font sizes, etc.
fonts: /* Ziggify:  std :: collections :: BTreeMap< OrderedFloat< f32> , Fonts>*/,
font_definitions: FontDefinitions,
memory: Memory,
animation_manager: AnimationManager,
plugins: Plugins,
/// All viewports share the same texture manager and texture namespace.
///
/// In all viewports, [`TextureId::default`] is special, and points to the font atlas.
/// The font-atlas texture _may_ be different across viewports, as they may have different
/// `pixels_per_point`, so we do special book-keeping for that.
/// See <https://github.com/emilk/egui/issues/3664>.
tex_manager: WrappedTextureManager,
/// Set during the frame, becomes active at the start of the next frame.
new_zoom_factor: ?f32,
os: OperatingSystem,
/// How deeply nested are we?
viewport_stack: ArrayList(ViewportIdPair),
/// What is the last viewport rendered?
last_viewport: ViewportId,
paint_stats: PaintStats,
request_repaint_callback: ?/* Ziggify:  Box< dyn Fn( RequestRepaintInfo) + Send + Sync>*/,
viewport_parents: /* Ziggify:  ViewportIdMap< ViewportId>*/,
viewports: /* Ziggify:  ViewportIdMap< ViewportState>*/,
embed_viewports: bool,
is_accesskit_enabled: bool,
accesskit_node_classes: accesskit.NodeClassSet,
loaders: /* Ziggify:  Arc< Loaders>*/,
};
// BEGIN: impl ContextImpl
fn beginFrameMut(self: *ContextImpl,new_raw_input: /* Ziggify: mut param */ RawInput)void{
const viewport_id = new_raw_input . viewport_id;
const parent_id = new_raw_input . viewports . get (  & viewport_id )  . andThen (  | v | v . parent )  . unwrapOrDefault (  ) ;
const ids = ViewportIdPair . fromSelfAndParent ( viewport_id , parent_id ) ;
const is_outermost_viewport = self . viewport_stack . isEmpty (  ) ;// not necessarily root, just outermost immediate viewport
self . viewport_stack . push ( ids ) ;
self . beginFrameRepaintLogic ( viewport_id ) ;
const viewport = self . viewports . entry ( viewport_id )  . orDefault (  ) ;
if(is_outermost_viewport){
if (/* Ziggify: Some ( new_zoom_factor ) */ self . new_zoom_factor . take (  ) ) {
const ratio = self . memory . options . zoom_factor / new_zoom_factor;
self . memory . options . zoom_factor = new_zoom_factor;
const input =  & viewport . input;
// This is a bit hacky, but is required to avoid jitter:
var rect = input . screen_rect;
rect . min =  ( ratio * rect . min . toVec2 (  )  )  . toPos2 (  ) ;
rect . max =  ( ratio * rect . max . toVec2 (  )  )  . toPos2 (  ) ;
new_raw_input . screen_rect = Some ( rect ) ;
// We should really scale everything else in the input too,
// but the `screen_rect` is the most important part.

}

}
const pixels_per_point = self . memory . options . zoom_factor * new_raw_input . viewport (  )  . native_pixels_per_point . unwrapOr ( 1.0 ) ;
const /* Ziggify: all_viewport_ids : ViewportIdSet */ =self . allViewportIds (  ) ;
const viewport = self . viewports . entry ( self . viewportId (  )  )  . orDefault (  ) ;
self . memory . beginFrame (  & viewport . input ,  & new_raw_input ,  & all_viewport_ids ) ;
viewport . input = std . mem . take ( &viewport . input )  . beginFrame ( new_raw_input , viewport . repaint . requestedImmediateRepaintPrevFrame (  )  , pixels_per_point ,  ) ;
viewport . frame_state . beginFrame (  & viewport . input ) ;
{
const /* Ziggify: area_order : HashMap < LayerId , usize > */ =self . memory . areas (  )  . order (  )  . iter (  )  . enumerate (  )  . map (  |  ( i , id )  |  (  * id , i )  )  . collect (  ) ;
const /* Ziggify: mut layers : Vec < LayerId > */ =viewport . widgets_prev_frame . layerIds (  )  . collect (  ) ;
layers . sortBy (  | a , b | {
if(a . order == b . order){
// Maybe both are windows, so respect area order:
area_order . get ( a )  . cmp (  & area_order . get ( b )  ) 
}
else{
// comparing e.g. background to tooltips
a . order . cmp (  & b . order ) 
}

}
 ) ;
viewport . hits = if (/* Ziggify: Some ( pos ) */ viewport . input . pointer . interactPos (  ) ) {
const interact_radius = self . memory . options . style . interaction . interact_radius;
crate . hit_test . hitTest (  & viewport . widgets_prev_frame ,  & layers ,  & self . memory . layer_transforms , pos , interact_radius ,  ) 
}
else{
WidgetHits . default (  ) 
}
;
viewport . interact_widgets = crate . interaction . interact (  & viewport . interact_widgets ,  & viewport . widgets_prev_frame ,  & viewport . hits ,  & viewport . input , self . memory . interactionMut (  )  ,  ) ;

}
// Ensure we register the background area so panels and background ui can catch clicks:
const screen_rect = viewport . input . screenRect (  ) ;
self . memory . areasMut (  )  . setState ( LayerId . background (  )  , containers . area . State {.pivot_pos = screen_rect . leftTop (  ) ,.pivot = Align2 . LEFT_TOP,.size = screen_rect . size (  ) ,.interactable = true,.edges_padded_for_resize = false,} ,  ) ;
if(self . is_accesskit_enabled){
crate . profile_scope !  ( "accesskit" ) ;
const id = crate . accesskitRootId (  ) ;
var builder = accesskit . NodeBuilder . new ( accesskit . Role . Window ) ;
const pixels_per_point = viewport . input . pixelsPerPoint (  ) ;
builder . setTransform ( accesskit . Affine . scale ( pixels_per_point . into (  )  )  ) ;
var node_builders = IdMap . default (  ) ;
node_builders . insert ( id , builder ) ;
viewport . frame_state . accesskit_state = Some ( AccessKitFrameState {.node_builders = node_builders,.parent_stack = vec ! [id],} ) ;

}
self . updateFontsMut (  ) ;

}
/// Load fonts unless already loaded.
fn updateFontsMut(self: *ContextImpl)void{
crate . profile_function !  (  ) ;
const input =  & self . viewport (  )  . input;
const pixels_per_point = input . pixelsPerPoint (  ) ;
const max_texture_side = input . max_texture_side;
if (/* Ziggify: Some ( font_definitions ) */ self . memory . new_font_definitions . take (  ) ) {
// New font definition loaded, so we need to reload all fonts.
self . fonts . clear (  ) ;
self . font_definitions = font_definitions;
log . debug !  ( "Loading new font definitions" ) ;

}
var is_new = false;
const fonts = self . fonts . entry ( pixels_per_point . into (  )  )  . orInsertWith (  or {
log . trace !  ( "Creating new Fonts for pixels_per_point={pixels_per_point}" ) ;
is_new = true;
crate . profile_scope !  ( "Fonts::new" ) ;
Fonts . new ( pixels_per_point , max_texture_side , self . font_definitions . clone (  )  ,  ) 
}
 ) ;
{
crate . profile_scope !  ( "Fonts::begin_frame" ) ;
fonts . beginFrame ( pixels_per_point , max_texture_side ) ;

}
if(is_new and self . memory . options . preload_font_glyphs){
crate . profile_scope !  ( "preload_font_glyphs" ) ;
// Preload the most common characters for the most common fonts.
// This is not very important to do, but may save a few GPU operations.
for (self . memory . options . style . text_styles . values (  ) ) |font_id|{
fonts . lock (  )  . fonts . font ( font_id )  . preloadCommonCharacters (  ) ;

}

}

}
fn accesskitNodeBuilder(self: *ContextImpl,id: Id)*accesskit.NodeBuilder{
const state = self . viewport (  )  . frame_state . accesskit_state . asMut (  )  . unwrap (  ) ;
const builders = &state . node_builders;
if (/* Ziggify: std :: collections :: hash_map :: Entry :: Vacant ( entry ) */ builders . entry ( id ) ) {
entry . insert ( Default . default (  )  ) ;
const parent_id = state . parent_stack . last (  )  . unwrap (  ) ;
const parent_builder = builders . getMut ( parent_id )  . unwrap (  ) ;
parent_builder . pushChild ( id . accesskitId (  )  ) ;

}
builders . getMut (  & id )  . unwrap (  ) 
}
fn pixelsPerPoint(self: *ContextImpl)f32{
self . viewport (  )  . input . pixels_per_point
}
/// Return the `ViewportId` of the current viewport.
///
/// For the root viewport this will return [`ViewportId::ROOT`].
pub fn viewportId(self: ContextImpl)ViewportId{
self . viewport_stack . last (  )  . copied (  )  . unwrapOrDefault (  )  . this
}
/// Return the `ViewportId` of his parent.
///
/// For the root viewport this will return [`ViewportId::ROOT`].
pub fn parentViewportId(self: ContextImpl)ViewportId{
self . viewport_stack . last (  )  . copied (  )  . unwrapOrDefault (  )  . parent
}
fn allViewportIds(self: ContextImpl)ViewportIdSet{
self . viewports . keys (  )  . copied (  )  . chain ( [ViewportId . ROOT] )  . collect (  ) 
}
/// The current active viewport
pub fn viewport(self: *ContextImpl)*ViewportState{
self . viewports . entry ( self . viewportId (  )  )  . orDefault (  ) 
}
fn viewportFor(self: *ContextImpl,viewport_id: ViewportId)*ViewportState{
self . viewports . entry ( viewport_id )  . orDefault (  ) 
}

// END: impl ContextImpl
// ----------------------------------------------------------------------------
/// Your handle to egui.
///
/// This is the first thing you need when working with egui.
/// Contains the [`InputState`], [`Memory`], [`PlatformOutput`], and more.
///
/// [`Context`] is cheap to clone, and any clones refers to the same mutable data
/// ([`Context`] uses refcounting internally).
///
/// ## Locking
/// All methods are marked `&self`; [`Context`] has interior mutability protected by an [`RwLock`].
///
/// To access parts of a `Context` you need to use some of the helper functions that take closures:
///
/// ```
/// # let ctx = egui::Context::default();
/// if ctx.input(|i| i.key_pressed(egui::Key::A)) {
///     ctx.output_mut(|o| o.copied_text = "Hello!".to_string());
/// }
/// ```
///
/// Within such a closure you may NOT recursively lock the same [`Context`], as that can lead to a deadlock.
/// Therefore it is important that any lock of [`Context`] is short-lived.
///
/// These are effectively transactional accesses.
///
/// [`Ui`] has many of the same accessor functions, and the same applies there.
///
/// ## Example:
///
/// ``` no_run
/// # fn handle_platform_output(_: egui::PlatformOutput) {}
/// # fn paint(textures_delta: egui::TexturesDelta, _: Vec<egui::ClippedPrimitive>) {}
/// let mut ctx = egui::Context::default();
///
/// // Game loop:
/// loop {
///     let raw_input = egui::RawInput::default();
///     let full_output = ctx.run(raw_input, |ctx| {
///         egui::CentralPanel::default().show(&ctx, |ui| {
///             ui.label("Hello world!");
///             if ui.button("Click me").clicked() {
///                 // take some action here
///             }
///         });
///     });
///     handle_platform_output(full_output.platform_output);
///     let clipped_primitives = ctx.tessellate(full_output.shapes, full_output.pixels_per_point);
///     paint(full_output.textures_delta, clipped_primitives);
/// }
/// ```
const Context = struct {
@"0":/* Ziggify:  Arc< RwLock< ContextImpl>>*/
};
// BEGIN: impl std :: fmt :: Debug for Context
fn fmt(self: Context,f: */* Ziggify:  std :: fmt :: Formatter< ' _>*/)std.fmt.Result{
f . debugStruct ( "Context" )  . finishNonExhaustive (  ) 
}

// END: impl std :: fmt :: Debug for Context
// BEGIN: impl std :: cmp :: PartialEq for Context
fn eq(self: Context,other: Context)bool{
Arc . ptrEq (  & self . 0 ,  & other . 0 ) 
}

// END: impl std :: cmp :: PartialEq for Context
// BEGIN: impl Default for Context
fn default()Context{
const ctx_impl = ContextImpl {.embed_viewports = true,/* Ziggify: .. Default :: default ( )*/};
const ctx = Self ( Arc . new ( RwLock . new ( ctx_impl )  )  ) ;
// Register built-in plugins:
crate . debug_text . register (  & ctx ) ;
crate . text_selection . LabelSelectionState . register (  & ctx ) ;
crate . DragAndDrop . register (  & ctx ) ;
ctx
}

// END: impl Default for Context
// BEGIN: impl Context
/// Do read-only (shared access) transaction on Context
fn read /* < R > */ (self: Context,reader: /* Ziggify:  impl FnOnce( & ContextImpl) -> R*/)R{
reader (  & self . 0 . read (  )  ) 
}
/// Do read-write (exclusive access) transaction on Context
fn write /* < R > */ (self: Context,writer: /* Ziggify:  impl FnOnce( & mut ContextImpl) -> R*/)R{
writer ( &self . 0 . write (  )  ) 
}
/// Run the ui code for one frame.
///
/// Put your widgets into a [`SidePanel`], [`TopBottomPanel`], [`CentralPanel`], [`Window`] or [`Area`].
///
/// This will modify the internal reference to point to a new generation of [`Context`].
/// Any old clones of this [`Context`] will refer to the old [`Context`], which will not get new input.
///
/// You can alternatively run [`Self::begin_frame`] and [`Context::end_frame`].
///
/// ```
/// // One egui context that you keep reusing:
/// let mut ctx = egui::Context::default();
///
/// // Each frame:
/// let input = egui::RawInput::default();
/// let full_output = ctx.run(input, |ctx| {
///     egui::CentralPanel::default().show(&ctx, |ui| {
///         ui.label("Hello egui!");
///     });
/// });
/// // handle full_output
/// ```
pub fn run(self: Context,new_input: RawInput,run_ui: /* Ziggify:  impl FnOnce( & Self)*/)FullOutput{
crate . profile_function !  (  ) ;
self . beginFrame ( new_input ) ;
runUi ( self ) ;
self . endFrame (  ) 
}
/// An alternative to calling [`Self::run`].
///
/// ```
/// // One egui context that you keep reusing:
/// let mut ctx = egui::Context::default();
///
/// // Each frame:
/// let input = egui::RawInput::default();
/// ctx.begin_frame(input);
///
/// egui::CentralPanel::default().show(&ctx, |ui| {
///     ui.label("Hello egui!");
/// });
///
/// let full_output = ctx.end_frame();
/// // handle full_output
/// ```
pub fn beginFrame(self: Context,new_input: RawInput)void{
crate . profile_function !  (  ) ;
self . read (  | ctx | ctx . plugins . clone (  )  )  . onBeginFrame ( self ) ;
self . write (  | ctx | ctx . beginFrameMut ( new_input )  ) ;

}

// END: impl Context
/// ## Borrows parts of [`Context`]
/// These functions all lock the [`Context`].
/// Please see the documentation of [`Context`] for how locking works!
// BEGIN: impl Context
/// Read-only access to [`InputState`].
///
/// Note that this locks the [`Context`].
///
/// ```
/// # let mut ctx = egui::Context::default();
/// ctx.input(|i| {
///     // ‚ö†Ô∏è Using `ctx` (even from other `Arc` reference) again here will lead to a deadlock!
/// });
///
/// if let Some(pos) = ctx.input(|i| i.pointer.hover_pos()) {
///     // This is fine!
/// }
/// ```
pub fn input /* < R > */ (self: Context,reader: /* Ziggify:  impl FnOnce( & InputState) -> R*/)R{
self . write ( move | ctx | reader (  & ctx . viewport (  )  . input )  ) 
}
/// This will create a `InputState::default()` if there is no input state for that viewport
pub fn inputFor /* < R > */ (self: Context,id: ViewportId,reader: /* Ziggify:  impl FnOnce( & InputState) -> R*/)R{
self . write ( move | ctx | reader (  & ctx . viewportFor ( id )  . input )  ) 
}
/// Read-write access to [`InputState`].
pub fn inputMut /* < R > */ (self: Context,writer: /* Ziggify:  impl FnOnce( & mut InputState) -> R*/)R{
self . inputMutFor ( self . viewportId (  )  , writer ) 
}
/// This will create a `InputState::default()` if there is no input state for that viewport
pub fn inputMutFor /* < R > */ (self: Context,id: ViewportId,writer: /* Ziggify:  impl FnOnce( & mut InputState) -> R*/)R{
self . write ( move | ctx | writer ( &ctx . viewportFor ( id )  . input )  ) 
}
/// Read-only access to [`Memory`].
pub fn memory /* < R > */ (self: Context,reader: /* Ziggify:  impl FnOnce( & Memory) -> R*/)R{
self . read ( move | ctx | reader (  & ctx . memory )  ) 
}
/// Read-write access to [`Memory`].
pub fn memoryMut /* < R > */ (self: Context,writer: /* Ziggify:  impl FnOnce( & mut Memory) -> R*/)R{
self . write ( move | ctx | writer ( &ctx . memory )  ) 
}
/// Read-only access to [`IdTypeMap`], which stores superficial widget state.
pub fn data /* < R > */ (self: Context,reader: /* Ziggify:  impl FnOnce( & IdTypeMap) -> R*/)R{
self . read ( move | ctx | reader (  & ctx . memory . data )  ) 
}
/// Read-write access to [`IdTypeMap`], which stores superficial widget state.
pub fn dataMut /* < R > */ (self: Context,writer: /* Ziggify:  impl FnOnce( & mut IdTypeMap) -> R*/)R{
self . write ( move | ctx | writer ( &ctx . memory . data )  ) 
}
/// Read-write access to [`GraphicLayers`], where painted [`crate::Shape`]s are written to.
pub fn graphicsMut /* < R > */ (self: Context,writer: /* Ziggify:  impl FnOnce( & mut GraphicLayers) -> R*/)R{
self . write ( move | ctx | writer ( &ctx . viewport (  )  . graphics )  ) 
}
/// Read-only access to [`GraphicLayers`], where painted [`crate::Shape`]s are written to.
pub fn graphics /* < R > */ (self: Context,reader: /* Ziggify:  impl FnOnce( & GraphicLayers) -> R*/)R{
self . write ( move | ctx | reader (  & ctx . viewport (  )  . graphics )  ) 
}
/// Read-only access to [`PlatformOutput`].
///
/// This is what egui outputs each frame.
///
/// ```
/// # let mut ctx = egui::Context::default();
/// ctx.output_mut(|o| o.cursor_icon = egui::CursorIcon::Progress);
/// ```
pub fn output /* < R > */ (self: Context,reader: /* Ziggify:  impl FnOnce( & PlatformOutput) -> R*/)R{
self . write ( move | ctx | reader (  & ctx . viewport (  )  . output )  ) 
}
/// Read-write access to [`PlatformOutput`].
pub fn outputMut /* < R > */ (self: Context,writer: /* Ziggify:  impl FnOnce( & mut PlatformOutput) -> R*/)R{
self . write ( move | ctx | writer ( &ctx . viewport (  )  . output )  ) 
}
/// Read-only access to [`FrameState`].
pub fn frameState /* < R > */ (self: Context,reader: /* Ziggify:  impl FnOnce( & FrameState) -> R*/)R{
self . write ( move | ctx | reader (  & ctx . viewport (  )  . frame_state )  ) 
}
/// Read-write access to [`FrameState`].
pub fn frameStateMut /* < R > */ (self: Context,writer: /* Ziggify:  impl FnOnce( & mut FrameState) -> R*/)R{
self . write ( move | ctx | writer ( &ctx . viewport (  )  . frame_state )  ) 
}
/// Read-only access to [`Fonts`].
///
/// Not valid until first call to [`Context::run()`].
/// That's because since we don't know the proper `pixels_per_point` until then.
pub fn fonts /* < R > */ (self: Context,reader: /* Ziggify:  impl FnOnce( & Fonts) -> R*/)R{
self . write ( move | ctx | {
const pixels_per_point = ctx . pixelsPerPoint (  ) ;
reader ( ctx . fonts . get (  & pixels_per_point . into (  )  )  . expect ( "No fonts available until first call to Context::run()" )  ,  ) 
}
 ) 
}
/// Read-only access to [`Options`].
pub fn options /* < R > */ (self: Context,reader: /* Ziggify:  impl FnOnce( & Options) -> R*/)R{
self . read ( move | ctx | reader (  & ctx . memory . options )  ) 
}
/// Read-write access to [`Options`].
pub fn optionsMut /* < R > */ (self: Context,writer: /* Ziggify:  impl FnOnce( & mut Options) -> R*/)R{
self . write ( move | ctx | writer ( &ctx . memory . options )  ) 
}
/// Read-only access to [`TessellationOptions`].
pub fn tessellationOptions /* < R > */ (self: Context,reader: /* Ziggify:  impl FnOnce( & TessellationOptions) -> R*/)R{
self . read ( move | ctx | reader (  & ctx . memory . options . tessellation_options )  ) 
}
/// Read-write access to [`TessellationOptions`].
pub fn tessellationOptionsMut /* < R > */ (self: Context,writer: /* Ziggify:  impl FnOnce( & mut TessellationOptions) -> R*/,)R{
self . write ( move | ctx | writer ( &ctx . memory . options . tessellation_options )  ) 
}
/// If the given [`Id`] has been used previously the same frame at at different position,
/// then an error will be printed on screen.
///
/// This function is already called for all widgets that do any interaction,
/// but you can call this from widgets that store state but that does not interact.
///
/// The given [`Rect`] should be approximately where the widget will be.
/// The most important thing is that [`Rect::min`] is approximately correct,
/// because that's where the warning will be painted. If you don't know what size to pick, just pick [`Vec2::ZERO`].
pub fn checkForIdClash(self: Context,id: Id,new_rect: Rect,what: str)void{
const prev_rect = self . frameStateMut ( move | state | state . used_ids . insert ( id , new_rect )  ) ;
if( ! self . options (  | opt | opt . warn_on_id_clash ) ){
return ;

}
const /* Ziggify: Some ( prev_rect ) */ =prev_rectelse{
return 
}
;
// it is ok to reuse the same ID for e.g. a frame around a widget,
// or to check for interaction with the same widget twice:
const is_same_rect = prev_rect . expand ( 0.1 )  . containsRect ( new_rect )  or new_rect . expand ( 0.1 )  . containsRect ( prev_rect ) ;
if(is_same_rect){
return ;

}
const show_error =  | widget_rect : Rect , text : String | {
const screen_rect = self . screenRect (  ) ;
const text = format !  ( "üî• {text}" ) ;
const color = self . style (  )  . visuals . error_fg_color;
const painter = self . debugPainter (  ) ;
painter . rectStroke ( widget_rect , 0.0 ,  ( 1.0 , color )  ) ;
const below = widget_rect . bottom (  )  + 32.0 < screen_rect . bottom (  ) ;
const text_rect = if(below){
painter . debugText ( widget_rect . leftBottom (  )  + vec2 ( 0.0 , 2.0 )  , Align2 . LEFT_TOP , color , text ,  ) 
}
else{
painter . debugText ( widget_rect . leftTop (  )  - vec2 ( 0.0 , 2.0 )  , Align2 . LEFT_BOTTOM , color , text ,  ) 
}
;
if (/* Ziggify: Some ( pointer_pos ) */ self . pointerHoverPos (  ) ) {
if(text_rect . contains ( pointer_pos ) ){
const tooltip_pos = if(below){
text_rect . leftBottom (  )  + vec2 ( 2.0 , 4.0 ) 
}
else{
text_rect . leftTop (  )  + vec2 ( 2.0 ,  - 4.0 ) 
}
;
painter . error ( tooltip_pos , format !  ( "Widget is {} this text.\n\n\nID clashes happens when things like Windows or CollapsingHeaders share names,\n\nor when things like Plot and Grid:s aren't given unique id_source:s.\n\n\nSometimes the solution is to use ui.push_id." , if(below){
"above"
}
else{
"below"
}
 )  ) ;

}

}

}
;
const id_str = id . shortDebugFormat (  ) ;
if(prev_rect . min . distance ( new_rect . min )  < 4.0){
showError ( new_rect , format !  ( "Double use of {what} ID {id_str}" )  ) ;

}
else{
showError ( prev_rect , format !  ( "First use of {what} ID {id_str}" )  ) ;
showError ( new_rect , format !  ( "Second use of {what} ID {id_str}" )  ) ;

}

}
// ---------------------------------------------------------------------
/// Create a widget and check for interaction.
///
/// If this is not called, the widget doesn't exist.
///
/// You should use [`Ui::interact`] instead.
///
/// If the widget already exists, its state (sense, Rect, etc) will be updated.
pub fn createWidget(self: Context,w: /* Ziggify: mut param */ WidgetRect)Response{
if( ! w . enabled){
w . sense . click = false;
w . sense . drag = false;

}
// Remember this widget
self . write (  | ctx | {
const viewport = ctx . viewport (  ) ;
// We add all widgets here, even non-interactive ones,
// because we need this list not only for checking for blocking widgets,
// but also to know when we have reached the widget we are checking for cover.
viewport . widgets_this_frame . insert ( w . layer_id , w ) ;
if(w . sense . focusable){
ctx . memory . interestedInFocus ( w . id ) ;

}

}
 ) ;
if( ! w . enabled or  ! w . sense . focusable or  ! w . layer_id . allowInteraction (  ) ){
// Not interested or allowed input:
self . memoryMut (  | mem | mem . surrenderFocus ( w . id )  ) ;

}
if(w . sense . interactive (  )  or w . sense . focusable){
self . checkForIdClash ( w . id , w . rect , "widget" ) ;

}
const res = self . getResponse ( w ) ;
if(w . sense . focusable){
// Make sure anything that can receive focus has an AccessKit node.
// TODO(mwcampbell): For nodes that are filled from widget info,
// some information is written to the node twice.
self . accesskitNodeBuilder ( w . id ,  | builder | res . fillAccesskitNodeCommon ( builder )  ) ;

}
res
}
/// Read the response of some widget, which may be called _before_ creating the widget (!).
///
/// This is because widget interaction happens at the start of the frame, using the previous frame's widgets.
///
/// If the widget was not visible the previous frame (or this frame), this will return `None`.
pub fn readResponse(self: Context,id: Id)?Response{
self . write (  | ctx | {
const viewport = ctx . viewport (  ) ;
viewport . widgets_this_frame . get ( id )  . orElse (  or viewport . widgets_prev_frame . get ( id )  )  . copied (  ) 
}
 )  . map (  | widget_rect | self . getResponse ( widget_rect )  ) 
}
/// Returns `true` if the widget with the given `Id` contains the pointer.
pub fn widgetContainsPointer(self: Context,id: Id)bool{
self . readResponse ( id )  . mapOr ( false ,  | response | response . contains_pointer ) 
}
/// Do all interaction for an existing widget, without (re-)registering it.
fn getResponse(self: Context,widget_rect: WidgetRect)Response{
const /* Ziggify: WidgetRect { id , layer_id , rect , interact_rect , sense , enabled , } */ =widget_rect;
const highlighted = self . frameState (  | fs | fs . highlight_this_frame . contains (  & id )  ) ;
var res = Response {.ctx = self . clone (  ) ,.layer_id = layer_id,.id = id,.rect = rect,.interact_rect = interact_rect,.sense = sense,.enabled = enabled,.contains_pointer = false,.hovered = false,.highlighted = highlighted,.clicked = Default . default (  ) ,.double_clicked = Default . default (  ) ,.triple_clicked = Default . default (  ) ,.drag_started = false,.dragged = false,.drag_stopped = false,.is_pointer_button_down_on = false,.interact_pointer_pos = None,.changed = false,};
const clicked_elsewhere = res . clickedElsewhere (  ) ;
self . write (  | ctx | {
const viewport = ctx . viewports . entry ( ctx . viewportId (  )  )  . orDefault (  ) ;
res . contains_pointer = viewport . interact_widgets . contains_pointer . contains (  & id ) ;
const input =  & viewport . input;
const memory = &ctx . memory;
if(sense . click and memory . hasFocus ( id )  and  ( input . keyPressed ( Key . Space )  or input . keyPressed ( Key . Enter )  ) ){
// Space/enter works like a primary click for e.g. selected buttons
res . clicked[PointerButton . Primary as usize] = true;

}
if(sense . click and input . hasAccesskitActionRequest ( id , accesskit . Action . Default ) ){
res . clicked[PointerButton . Primary as usize] = true;

}
const interaction = memory . interaction (  ) ;
res . is_pointer_button_down_on = interaction . potential_click_id == Some ( id )  or interaction . potential_drag_id == Some ( id ) ;
if(res . enabled){
res . hovered = viewport . interact_widgets . hovered . contains (  & id ) ;
res . dragged = Some ( id )  == viewport . interact_widgets . dragged;
res . drag_started = Some ( id )  == viewport . interact_widgets . drag_started;
res . drag_stopped = Some ( id )  == viewport . interact_widgets . drag_stopped;

}
const clicked = Some ( id )  == viewport . interact_widgets . clicked;
for ( & input . pointer . pointer_events) |pointer_event|{
if (/* Ziggify: PointerEvent :: Released { click , button } */ pointer_event) {
if(sense . click and clicked){
if (/* Ziggify: Some ( click ) */ click) {
res . clicked[ * button as usize] = true;
res . double_clicked[ * button as usize] = click . isDouble (  ) ;
res . triple_clicked[ * button as usize] = click . isTriple (  ) ;

}

}
res . is_pointer_button_down_on = false;
res . dragged = false;

}

}
// is_pointer_button_down_on is false when released, but we want interact_pointer_pos
// to still work.
const is_interacted_with = res . is_pointer_button_down_on or clicked or res . drag_stopped;
if(is_interacted_with){
res . interact_pointer_pos = input . pointer . interactPos (  ) ;
if (/* Ziggify: ( Some ( transform ) , Some ( pos ) ) */  ( memory . layer_transforms . get (  & res . layer_id )  , &res . interact_pointer_pos ,  ) ) {
 * pos = transform . inverse (  )  *  * pos;

}

}
if(input . pointer . anyDown (  )  and  ! res . is_pointer_button_down_on){
// We don't hover widgets while interacting with *other* widgets:
res . hovered = false;

}
if(clicked_elsewhere and memory . hasFocus ( id ) ){
memory . surrenderFocus ( id ) ;

}
if(res . dragged (  )  and  ! memory . hasFocus ( id ) ){
// e.g.: remove focus from a widget when you drag something else
memory . stopTextInput (  ) ;

}

}
 ) ;
res
}
/// Get a full-screen painter for a new or existing layer
pub fn layerPainter(self: Context,layer_id: LayerId)Painter{
const screen_rect = self . screenRect (  ) ;
Painter . new ( self . clone (  )  , layer_id , screen_rect ) 
}
/// Paint on top of everything else
pub fn debugPainter(self: Context)Painter{
Self . layerPainter ( self , LayerId . debug (  )  ) 
}
/// Print this text next to the cursor at the end of the frame.
///
/// If you call this multiple times, the text will be appended.
///
/// This only works if compiled with `debug_assertions`.
///
/// ```
/// # let ctx = egui::Context::default();
/// # let state = true;
/// ctx.debug_text(format!("State: {state:?}"));
/// ```
///
/// This is just a convenience for calling [`crate::debug_text::print`].
pub fn debugText(self: Context,text: WidgetText)void{
crate . debug_text . print ( self , text ) ;

}
/// What operating system are we running on?
///
/// When compiling natively, this is
/// figured out from the `target_os`.
///
/// For web, this can be figured out from the user-agent,
/// and is done so by [`eframe`](https://github.com/emilk/egui/tree/master/crates/eframe).
pub fn os(self: Context)OperatingSystem{
self . read (  | ctx | ctx . os ) 
}
/// Set the operating system we are running on.
///
/// If you are writing wasm-based integration for egui you
/// may want to set this based on e.g. the user-agent.
pub fn setOs(self: Context,os: OperatingSystem)void{
self . write (  | ctx | ctx . os = os ) ;

}
/// Set the cursor icon.
///
/// Equivalent to:
/// ```
/// # let ctx = egui::Context::default();
/// ctx.output_mut(|o| o.cursor_icon = egui::CursorIcon::PointingHand);
/// ```
pub fn setCursorIcon(self: Context,cursor_icon: CursorIcon)void{
self . outputMut (  | o | o . cursor_icon = cursor_icon ) ;

}
/// Open an URL in a browser.
///
/// Equivalent to:
/// ```
/// # let ctx = egui::Context::default();
/// # let open_url = egui::OpenUrl::same_tab("http://www.example.com");
/// ctx.output_mut(|o| o.open_url = Some(open_url));
/// ```
pub fn openUrl(self: Context,open_url: crate.OpenUrl)void{
self . outputMut (  | o | o . open_url = Some ( open_url )  ) ;

}
/// Copy the given text to the system clipboard.
///
/// Empty strings are ignored.
///
/// Equivalent to:
/// ```
/// # let ctx = egui::Context::default();
/// ctx.output_mut(|o| o.copied_text = "Copy this".to_owned());
/// ```
pub fn copyText(self: Context,text: String)void{
self . outputMut (  | o | o . copied_text = text ) ;

}
/// Format the given shortcut in a human-readable way (e.g. `Ctrl+Shift+X`).
///
/// Can be used to get the text for [`Button::shortcut_text`].
pub fn formatShortcut(self: Context,shortcut: KeyboardShortcut)String{
const os = self . os (  ) ;
const is_mac = matches !  ( os , OperatingSystem . Mac | OperatingSystem . IOS ) ;
const can_show_symbols =  or {
const /* Ziggify: ModifierNames { alt , ctrl , shift , mac_cmd , .. } */ =ModifierNames . SYMBOLS;
const font_id = TextStyle . Body . resolve (  & self . style (  )  ) ;
self . fonts (  | f | {
var lock = f . lock (  ) ;
const font = lock . fonts . font (  & font_id ) ;
font . hasGlyphs ( alt )  and font . hasGlyphs ( ctrl )  and font . hasGlyphs ( shift )  and font . hasGlyphs ( mac_cmd ) 
}
 ) 
}
;
if(is_mac and canShowSymbols (  ) ){
shortcut . format (  & ModifierNames . SYMBOLS , is_mac ) 
}
else{
shortcut . format (  & ModifierNames . NAMES , is_mac ) 
}

}
/// The current frame number for the current viewport.
///
/// Starts at zero, and is incremented at the end of [`Self::run`] or by [`Self::end_frame`].
///
/// Between calls to [`Self::run`], this is the frame number of the coming frame.
pub fn frameNr(self: Context)u64{
self . frameNrFor ( self . viewportId (  )  ) 
}
/// The current frame number.
///
/// Starts at zero, and is incremented at the end of [`Self::run`] or by [`Self::end_frame`].
///
/// Between calls to [`Self::run`], this is the frame number of the coming frame.
pub fn frameNrFor(self: Context,id: ViewportId)u64{
self . read (  | ctx | ctx . viewports . get (  & id )  . mapOr ( 0 ,  | v | v . repaint . frame_nr )  ) 
}
/// Call this if there is need to repaint the UI, i.e. if you are showing an animation.
///
/// If this is called at least once in a frame, then there will be another frame right after this.
/// Call as many times as you wish, only one repaint will be issued.
///
/// To request repaint with a delay, use [`Self::request_repaint_after`].
///
/// If called from outside the UI thread, the UI thread will wake up and run,
/// provided the egui integration has set that up via [`Self::set_request_repaint_callback`]
/// (this will work on `eframe`).
///
/// This will repaint the current viewport.
pub fn requestRepaint(self: Context)void{
self . requestRepaintOf ( self . viewportId (  )  ) ;

}
/// Call this if there is need to repaint the UI, i.e. if you are showing an animation.
///
/// If this is called at least once in a frame, then there will be another frame right after this.
/// Call as many times as you wish, only one repaint will be issued.
///
/// To request repaint with a delay, use [`Self::request_repaint_after_for`].
///
/// If called from outside the UI thread, the UI thread will wake up and run,
/// provided the egui integration has set that up via [`Self::set_request_repaint_callback`]
/// (this will work on `eframe`).
///
/// This will repaint the specified viewport.
pub fn requestRepaintOf(self: Context,id: ViewportId)void{
const cause = RepaintCause . new (  ) ;
self . write (  | ctx | ctx . requestRepaint ( id , cause )  ) ;

}
/// Request repaint after at most the specified duration elapses.
///
/// The backend can chose to repaint sooner, for instance if some other code called
/// this method with a lower duration, or if new events arrived.
///
/// The function can be multiple times, but only the *smallest* duration will be considered.
/// So, if the function is called two times with `1 second` and `2 seconds`, egui will repaint
/// after `1 second`
///
/// This is primarily useful for applications who would like to save battery by avoiding wasted
/// redraws when the app is not in focus. But sometimes the GUI of the app might become stale
/// and outdated if it is not updated for too long.
///
/// Let's say, something like a stopwatch widget that displays the time in seconds. You would waste
/// resources repainting multiple times within the same second (when you have no input),
/// just calculate the difference of duration between current time and next second change,
/// and call this function, to make sure that you are displaying the latest updated time, but
/// not wasting resources on needless repaints within the same second.
///
/// ### Quirk:
/// Duration begins at the next frame. Let's say for example that it's a very inefficient app
/// and takes 500 milliseconds per frame at 2 fps. The widget / user might want a repaint in
/// next 500 milliseconds. Now, app takes 1000 ms per frame (1 fps) because the backend event
/// timeout takes 500 milliseconds AFTER the vsync swap buffer.
/// So, it's not that we are requesting repaint within X duration. We are rather timing out
/// during app idle time where we are not receiving any new input events.
///
/// This repaints the current viewport
pub fn requestRepaintAfter(self: Context,duration: Duration)void{
self . requestRepaintAfterFor ( duration , self . viewportId (  )  ) ;

}
/// Request repaint after at most the specified duration elapses.
///
/// The backend can chose to repaint sooner, for instance if some other code called
/// this method with a lower duration, or if new events arrived.
///
/// The function can be multiple times, but only the *smallest* duration will be considered.
/// So, if the function is called two times with `1 second` and `2 seconds`, egui will repaint
/// after `1 second`
///
/// This is primarily useful for applications who would like to save battery by avoiding wasted
/// redraws when the app is not in focus. But sometimes the GUI of the app might become stale
/// and outdated if it is not updated for too long.
///
/// Let's say, something like a stopwatch widget that displays the time in seconds. You would waste
/// resources repainting multiple times within the same second (when you have no input),
/// just calculate the difference of duration between current time and next second change,
/// and call this function, to make sure that you are displaying the latest updated time, but
/// not wasting resources on needless repaints within the same second.
///
/// ### Quirk:
/// Duration begins at the next frame. Let's say for example that it's a very inefficient app
/// and takes 500 milliseconds per frame at 2 fps. The widget / user might want a repaint in
/// next 500 milliseconds. Now, app takes 1000 ms per frame (1 fps) because the backend event
/// timeout takes 500 milliseconds AFTER the vsync swap buffer.
/// So, it's not that we are requesting repaint within X duration. We are rather timing out
/// during app idle time where we are not receiving any new input events.
///
/// This repaints the specified viewport
pub fn requestRepaintAfterFor(self: Context,duration: Duration,id: ViewportId)void{
const cause = RepaintCause . new (  ) ;
self . write (  | ctx | ctx . requestRepaintAfter ( duration , id , cause )  ) ;

}
/// Was a repaint requested last frame for the current viewport?
pub fn requestedRepaintLastFrame(self: Context)bool{
self . requestedRepaintLastFrameFor (  & self . viewportId (  )  ) 
}
/// Was a repaint requested last frame for the given viewport?
pub fn requestedRepaintLastFrameFor(self: Context,viewport_id: ViewportId)bool{
self . read (  | ctx | ctx . requestedImmediateRepaintPrevFrame ( viewport_id )  ) 
}
/// Has a repaint been requested for the current viewport?
pub fn hasRequestedRepaint(self: Context)bool{
self . hasRequestedRepaintFor (  & self . viewportId (  )  ) 
}
/// Has a repaint been requested for the given viewport?
pub fn hasRequestedRepaintFor(self: Context,viewport_id: ViewportId)bool{
self . read (  | ctx | ctx . hasRequestedRepaint ( viewport_id )  ) 
}
/// Why are we repainting?
///
/// This can be helpful in debugging why egui is constantly repainting.
pub fn repaintCauses(self: Context)ArrayList(RepaintCause){
self . read (  | ctx | {
ctx . viewports . get (  & ctx . viewportId (  )  )  . map (  | v | v . repaint . causes . clone (  )  ) 
}
 )  . unwrapOrDefault (  ) 
}
/// For integrations: this callback will be called when an egui user calls [`Self::request_repaint`] or [`Self::request_repaint_after`].
///
/// This lets you wake up a sleeping UI thread.
///
/// Note that only one callback can be set. Any new call overrides the previous callback.
pub fn setRequestRepaintCallback(self: Context,callback: /* Ziggify:  impl Fn( RequestRepaintInfo) + Send + Sync + ' static*/,)void{
const callback = Box . new ( callback ) ;
self . write (  | ctx | ctx . request_repaint_callback = Some ( callback )  ) ;

}

// END: impl Context
/// Callbacks
// BEGIN: impl Context
/// Call the given callback at the start of each frame
/// of each viewport.
///
/// This can be used for egui _plugins_.
/// See [`crate::debug_text`] for an example.
pub fn onBeginFrame(self: Context,debug_name: str,cb: ContextCallback)void{
const named_cb = NamedContextCallback {.debug_name = debug_name,.callback = cb,};
self . write (  | ctx | ctx . plugins . on_begin_frame . push ( named_cb )  ) ;

}
/// Call the given callback at the end of each frame
/// of each viewport.
///
/// This can be used for egui _plugins_.
/// See [`crate::debug_text`] for an example.
pub fn onEndFrame(self: Context,debug_name: str,cb: ContextCallback)void{
const named_cb = NamedContextCallback {.debug_name = debug_name,.callback = cb,};
self . write (  | ctx | ctx . plugins . on_end_frame . push ( named_cb )  ) ;

}

// END: impl Context
// BEGIN: impl Context
/// Tell `egui` which fonts to use.
///
/// The default `egui` fonts only support latin and cyrillic alphabets,
/// but you can call this to install additional fonts that support e.g. korean characters.
///
/// The new fonts will become active at the start of the next frame.
pub fn setFonts(self: Context,font_definitions: FontDefinitions)void{
crate . profile_function !  (  ) ;
const pixels_per_point = self . pixelsPerPoint (  ) ;
var update_fonts = true;
self . read (  | ctx | {
if (/* Ziggify: Some ( current_fonts ) */ ctx . fonts . get (  & pixels_per_point . into (  )  ) ) {
// NOTE: this comparison is expensive since it checks TTF data for equality
if(current_fonts . lock (  )  . fonts . definitions (  )  ==  & font_definitions){
update_fonts = false;// no need to update

}

}

}
 ) ;
if(update_fonts){
self . memoryMut (  | mem | mem . new_font_definitions = Some ( font_definitions )  ) ;

}

}
/// The [`Style`] used by all subsequent windows, panels etc.
pub fn style(self: Context)/* Ziggify:  Arc< Style>*/{
self . options (  | opt | opt . style . clone (  )  ) 
}
/// Mutate the [`Style`] used by all subsequent windows, panels etc.
///
/// Example:
/// ```
/// # let mut ctx = egui::Context::default();
/// ctx.style_mut(|style| {
///     style.spacing.item_spacing = egui::vec2(10.0, 20.0);
/// });
/// ```
pub fn styleMut(self: Context,mutate_style: /* Ziggify:  impl FnOnce( & mut Style)*/)void{
self . optionsMut (  | opt | mutateStyle ( std . sync . Arc . makeMut ( &opt . style )  )  ) ;

}
/// The [`Style`] used by all new windows, panels etc.
///
/// You can also change this using [`Self::style_mut]`
///
/// You can use [`Ui::style_mut`] to change the style of a single [`Ui`].
pub fn setStyle(self: Context,style: /* Ziggify:  Arc< Style>*/)void{
self . optionsMut (  | opt | opt . style = style . into (  )  ) ;

}
/// The [`Visuals`] used by all subsequent windows, panels etc.
///
/// You can also use [`Ui::visuals_mut`] to change the visuals of a single [`Ui`].
///
/// Example:
/// ```
/// # let mut ctx = egui::Context::default();
/// ctx.set_visuals(egui::Visuals::light()); // Switch to light mode
/// ```
pub fn setVisuals(self: Context,visuals: crate.Visuals)void{
self . optionsMut (  | opt | std . sync . Arc . makeMut ( &opt . style )  . visuals = visuals ) ;

}
/// The number of physical pixels for each logical point.
///
/// This is calculated as [`Self::zoom_factor`] * [`Self::native_pixels_per_point`]
pub fn pixelsPerPoint(self: Context)f32{
self . input (  | i | i . pixels_per_point ) 
}
/// Set the number of physical pixels for each logical point.
/// Will become active at the start of the next frame.
///
/// This will actually translate to a call to [`Self::set_zoom_factor`].
pub fn setPixelsPerPoint(self: Context,pixels_per_point: f32)void{
if(pixels_per_point !  = self . pixelsPerPoint (  ) ){
self . setZoomFactor ( pixels_per_point / self . nativePixelsPerPoint (  )  . unwrapOr ( 1.0 )  ) ;

}

}
/// The number of physical pixels for each logical point on this monitor.
///
/// This is given as input to egui via [`ViewportInfo::native_pixels_per_point`]
/// and cannot be changed.
pub fn nativePixelsPerPoint(self: Context)?f32{
self . input (  | i | i . viewport (  )  . native_pixels_per_point ) 
}
/// Global zoom factor of the UI.
///
/// This is used to calculate the `pixels_per_point`
/// for the UI as `pixels_per_point = zoom_fator * native_pixels_per_point`.
///
/// The default is 1.0.
/// Make larger to make everything larger.
pub fn zoomFactor(self: Context)f32{
self . options (  | o | o . zoom_factor ) 
}
/// Sets zoom factor of the UI.
/// Will become active at the start of the next frame.
///
/// Note that calling this will not update [`Self::zoom_factor`] until the end of the frame.
///
/// This is used to calculate the `pixels_per_point`
/// for the UI as `pixels_per_point = zoom_fator * native_pixels_per_point`.
///
/// The default is 1.0.
/// Make larger to make everything larger.
///
/// It is better to call this than modifying
/// [`Options::zoom_factor`].
pub fn setZoomFactor(self: Context,zoom_factor: f32)void{
const cause = RepaintCause . new (  ) ;
self . write (  | ctx | {
if(ctx . memory . options . zoom_factor !  = zoom_factor){
ctx . new_zoom_factor = Some ( zoom_factor ) ;
for (ctx . allViewportIds (  ) ) |viewport_id|{
ctx . requestRepaint ( viewport_id , cause . clone (  )  ) ;

}

}

}
 ) ;

}
/// Useful for pixel-perfect rendering
pub fn roundToPixel(self: Context,point: f32)f32{
const pixels_per_point = self . pixelsPerPoint (  ) ;
 ( point * pixels_per_point )  . round (  )  / pixels_per_point
}
/// Useful for pixel-perfect rendering
pub fn roundPosToPixels(self: Context,pos: Pos2)Pos2{
pos2 ( self . roundToPixel ( pos . x )  , self . roundToPixel ( pos . y )  ) 
}
/// Useful for pixel-perfect rendering
pub fn roundVecToPixels(self: Context,vec: Vec2)Vec2{
vec2 ( self . roundToPixel ( vec . x )  , self . roundToPixel ( vec . y )  ) 
}
/// Useful for pixel-perfect rendering
pub fn roundRectToPixels(self: Context,rect: Rect)Rect{
Rect {.min = self . roundPosToPixels ( rect . min ) ,.max = self . roundPosToPixels ( rect . max ) ,}
}
/// Allocate a texture.
///
/// This is for advanced users.
/// Most users should use [`crate::Ui::image`] or [`Self::try_load_texture`]
/// instead.
///
/// In order to display an image you must convert it to a texture using this function.
/// The function will hand over the image data to the egui backend, which will
/// upload it to the GPU.
///
/// ‚ö†Ô∏è Make sure to only call this ONCE for each image, i.e. NOT in your main GUI code.
/// The call is NOT immediate safe.
///
/// The given name can be useful for later debugging, and will be visible if you call [`Self::texture_ui`].
///
/// For how to load an image, see [`ImageData`] and [`ColorImage::from_rgba_unmultiplied`].
///
/// ```
/// struct MyImage {
///     texture: Option<egui::TextureHandle>,
/// }
///
/// impl MyImage {
///     fn ui(&mut self, ui: &mut egui::Ui) {
///         let texture: &egui::TextureHandle = self.texture.get_or_insert_with(|| {
///             // Load the texture only once.
///             ui.ctx().load_texture(
///                 "my-image",
///                 egui::ColorImage::example(),
///                 Default::default()
///             )
///         });
///
///         // Show the image:
///         ui.image((texture.id(), texture.size_vec2()));
///     }
/// }
/// ```
///
/// See also [`crate::ImageData`], [`crate::Ui::image`] and [`crate::Image`].
pub fn loadTexture(self: Context,name: String,image: ImageData,options: TextureOptions,)TextureHandle{
const name = name . into (  ) ;
const image = image . into (  ) ;
const max_texture_side = self . input (  | i | i . max_texture_side ) ;
crate . egui_assert !  ( image . width (  )  <= max_texture_side and image . height (  )  <= max_texture_side , "Texture {:?} has size {}x{}, but the maximum texture side is {}" , name , image . width (  )  , image . height (  )  , max_texture_side ) ;
const tex_mngr = self . texManager (  ) ;
const tex_id = tex_mngr . write (  )  . alloc ( name , image , options ) ;
TextureHandle . new ( tex_mngr , tex_id ) 
}
/// Low-level texture manager.
///
/// In general it is easier to use [`Self::load_texture`] and [`TextureHandle`].
///
/// You can show stats about the allocated textures using [`Self::texture_ui`].
pub fn texManager(self: Context)/* Ziggify:  Arc< RwLock< epaint :: textures :: TextureManager>>*/{
self . read (  | ctx | ctx . tex_manager . 0 . clone (  )  ) 
}
// ---------------------------------------------------------------------
/// Constrain the position of a window/area so it fits within the provided boundary.
///
/// If area is `None`, will constrain to [`Self::available_rect`].
pub fn constrainWindowRectToArea(self: Context,window: Rect,area: ?Rect)Rect{
var area = area . unwrapOrElse (  or self . availableRect (  )  ) ;
if(window . width (  )  > area . width (  ) ){
// Allow overlapping side bars.
// This is important for small screens, e.g. mobiles running the web demo.
const screen_rect = self . screenRect (  ) ;
 ( area . min . x , area . max . x )  =  ( screen_rect . min . x , screen_rect . max . x ) ;

}
if(window . height (  )  > area . height (  ) ){
// Allow overlapping top/bottom bars:
const screen_rect = self . screenRect (  ) ;
 ( area . min . y , area . max . y )  =  ( screen_rect . min . y , screen_rect . max . y ) ;

}
var pos = window . min;
// Constrain to screen, unless window is too large to fit:
const margin_x =  ( window . width (  )  - area . width (  )  )  . atLeast ( 0.0 ) ;
const margin_y =  ( window . height (  )  - area . height (  )  )  . atLeast ( 0.0 ) ;
pos . x = pos . x . atMost ( area . right (  )  + margin_x - window . width (  )  ) ;// move left if needed
pos . x = pos . x . atLeast ( area . left (  )  - margin_x ) ;// move right if needed
pos . y = pos . y . atMost ( area . bottom (  )  + margin_y - window . height (  )  ) ;// move right if needed
pos . y = pos . y . atLeast ( area . top (  )  - margin_y ) ;// move down if needed
pos = self . roundPosToPixels ( pos ) ;
Rect . fromMinSize ( pos , window . size (  )  ) 
}

// END: impl Context
// BEGIN: impl Context
/// Call at the end of each frame.
pub fn endFrame(self: Context)FullOutput{
crate . profile_function !  (  ) ;
if(self . options (  | o | o . zoom_with_keyboard ) ){
crate . gui_zoom . zoomWithKeyboard ( self ) ;

}
self . read (  | ctx | ctx . plugins . clone (  )  )  . onEndFrame ( self ) ;
self . debugPainting (  ) ;
self . write (  | ctx | ctx . endFrame (  )  ) 
}
fn debugPainting(self: Context)void{
const paint_widget =  | widget :  & WidgetRect , text :  & str , color : Color32 | {
const rect = widget . interact_rect;
if(rect . isPositive (  ) ){
const painter = Painter . new ( self . clone (  )  , widget . layer_id , Rect . EVERYTHING ) ;
painter . debugRect ( rect , color , text ) ;

}

}
;
const paint_widget_id =  | id : Id , text :  & str , color : Color32 | {
if (/* Ziggify: Some ( widget ) */ self . write (  | ctx | ctx . viewport (  )  . widgets_this_frame . get ( id )  . cloned (  )  ) ) {
paintWidget (  & widget , text , color ) ;

}

}
;
if(self . style (  )  . debug . show_interactive_widgets){
// Show all interactive widgets:
const rects = self . write (  | ctx | ctx . viewport (  )  . widgets_this_frame . clone (  )  ) ;
for (rects . layers (  ) ) |/* Ziggify: (rects, layer_id) */|{
const painter = Painter . new ( self . clone (  )  ,  * layer_id , Rect . EVERYTHING ) ;
for (rects) |rect|{
if(rect . sense . interactive (  ) ){
const /* Ziggify: ( color , text ) */ =if(rect . sense . click and rect . sense . drag){
 ( Color32 . fromRgb ( 0x88 , 0 , 0x88 )  , "click+drag" ) 
}
else if(rect . sense . click){
 ( Color32 . fromRgb ( 0x88 , 0 , 0 )  , "click" ) 
}
else if(rect . sense . drag){
 ( Color32 . fromRgb ( 0 , 0 , 0x88 )  , "drag" ) 
}
else{
continue;
// (Color32::from_rgb(0, 0, 0x88), "hover")

}
;
painter . debugRect ( rect . interact_rect , color , text ) ;

}

}

}
// Show the ones actually interacted with:
{
const interact_widgets = self . write (  | ctx | ctx . viewport (  )  . interact_widgets . clone (  )  ) ;
const /* Ziggify: InteractionSnapshot { clicked , drag_started : _ , dragged , drag_stopped : _ , contains_pointer , hovered , } */ =interact_widgets;
if(false){
for (contains_pointer) |widget|{
paintWidgetId ( widget , "contains_pointer" , Color32 . BLUE ) ;

}

}
if(true){
for (hovered) |widget|{
paintWidgetId ( widget , "hovered" , Color32 . WHITE ) ;

}

}
for ( & clicked) |/* Ziggify: & widget*/|{
paintWidgetId ( widget , "clicked" , Color32 . RED ) ;

}
for ( & dragged) |/* Ziggify: & widget*/|{
paintWidgetId ( widget , "dragged" , Color32 . GREEN ) ;

}

}

}
if(self . style (  )  . debug . show_widget_hits){
const hits = self . write (  | ctx | ctx . viewport (  )  . hits . clone (  )  ) ;
const /* Ziggify: WidgetHits { contains_pointer , click , drag , } */ =hits;
if(false){
for ( & contains_pointer) |widget|{
paintWidget ( widget , "contains_pointer" , Color32 . BLUE ) ;

}

}
for ( & click) |widget|{
paintWidget ( widget , "click" , Color32 . RED ) ;

}
for ( & drag) |widget|{
paintWidget ( widget , "drag" , Color32 . GREEN ) ;

}

}

}

// END: impl Context
// BEGIN: impl ContextImpl
fn endFrame(self: *ContextImpl)FullOutput{
const ended_viewport_id = self . viewportId (  ) ;
const viewport = self . viewports . entry ( ended_viewport_id )  . orDefault (  ) ;
const pixels_per_point = viewport . input . pixels_per_point;
viewport . repaint . frame_nr +  = 1;
self . memory . endFrame (  & viewport . frame_state . used_ids ) ;
if (/* Ziggify: Some ( fonts ) */ self . fonts . get (  & pixels_per_point . into (  )  ) ) {
const tex_mngr = &self . tex_manager . 0 . write (  ) ;
if (/* Ziggify: Some ( font_image_delta ) */ fonts . fontImageDelta (  ) ) {
// A partial font atlas update, e.g. a new glyph has been entered.
tex_mngr . set ( TextureId . default (  )  , font_image_delta ) ;

}
if(1 < self . fonts . len (  ) ){
// We have multiple different `pixels_per_point`,
// e.g. because we have many viewports spread across
// monitors with different DPI scaling.
// All viewports share the same texture namespace and renderer,
// so the all use `TextureId::default()` for the font texture.
// This is a problem.
// We solve this with a hack: we always upload the full font atlas
// every frame, for all viewports.
// This ensures it is up-to-date, solving
// https://github.com/emilk/egui/issues/3664
// at the cost of a lot of performance.
// (This will override any smaller delta that was uploaded above.)
crate . profile_scope !  ( "full_font_atlas_update" ) ;
const full_delta = ImageDelta . full ( fonts . image (  )  , TextureAtlas . textureOptions (  )  ) ;
tex_mngr . set ( TextureId . default (  )  , full_delta ) ;

}

}
// Inform the backend of all textures that have been updated (including font atlas).
const textures_delta = self . tex_manager . 0 . write (  )  . takeDelta (  ) ;
const /* Ziggify: mut platform_output : PlatformOutput */ =std . mem . take ( &viewport . output ) ;
{
crate . profile_scope !  ( "accesskit" ) ;
const state = viewport . frame_state . accesskit_state . take (  ) ;
if (/* Ziggify: Some ( state ) */ state) {
const root_id = crate . accesskitRootId (  )  . accesskitId (  ) ;
const nodes = {
state . node_builders . intoIter (  )  . map (  |  ( id , builder )  | {
 ( id . accesskitId (  )  , builder . build ( &self . accesskit_node_classes )  ,  ) 
}
 )  . collect (  ) 
}
;
const focus_id = self . memory . focus (  )  . mapOr ( root_id ,  | id | id . accesskitId (  )  ) ;
platform_output . accesskit_update = Some ( accesskit . TreeUpdate {.nodes = nodes,.tree = Some ( accesskit . Tree . new ( root_id )  ) ,.focus = focus_id,} ) ;

}

}
const shapes = viewport . graphics . drain ( self . memory . areas (  )  . order (  )  ,  & self . memory . layer_transforms ) ;
var repaint_needed = false;
{
if(self . memory . options . repaint_on_widget_change){
crate . profile_function !  ( "compare-widget-rects" ) ;
if(viewport . widgets_prev_frame !  = viewport . widgets_this_frame){
repaint_needed = true;// Some widget has moved

}

}
std . mem . swap ( &viewport . widgets_prev_frame , &viewport . widgets_this_frame ,  ) ;
viewport . widgets_this_frame . clear (  ) ;

}
if(repaint_needed or viewport . input . wantsRepaint (  ) ){
self . requestRepaint ( ended_viewport_id , RepaintCause . new (  )  ) ;

}
//  -------------------
const all_viewport_ids = self . allViewportIds (  ) ;
self . last_viewport = ended_viewport_id;
self . viewports . retain (  |  & id , viewport | {
const parent =  * self . viewport_parents . entry ( id )  . orDefault (  ) ;
if( ! all_viewport_ids . contains (  & parent ) ){
log . debug !  ( "Removing viewport {:?} ({:?}): the parent is gone" , id , viewport . builder . title ) ;
return false;

}
const is_our_child = parent == ended_viewport_id and id !  = ViewportId . ROOT;
if(is_our_child){
if( ! viewport . used){
log . debug !  ( "Removing viewport {:?} ({:?}): it was never used this frame" , id , viewport . builder . title ) ;
return false;// Only keep children that have been updated this frame

}
viewport . used = false;// reset so we can check again next frame

}
true
}
 ) ;
// If we are an immediate viewport, this will resume the previous viewport.
self . viewport_stack . pop (  ) ;
// The last viewport is not necessarily the root viewport,
// just the top _immediate_ viewport.
const is_last = self . viewport_stack . isEmpty (  ) ;
const viewport_output = self . viewports . iterMut (  )  . map (  |  (  & id , viewport )  | {
const parent =  * self . viewport_parents . entry ( id )  . orDefault (  ) ;
const commands = if(is_last){
// Let the primary immediate viewport handle the commands of its children too.
// This can make things easier for the backend, as otherwise we may get commands
// that affect a viewport while its egui logic is running.
std . mem . take ( &viewport . commands ) 
}
else{
vec ! []
}
;
 ( id , ViewportOutput {.parent = parent,.class = viewport . class,.builder = viewport . builder . clone (  ) ,.viewport_ui_cb = viewport . viewport_ui_cb . clone (  ) ,.commands = commands,.repaint_delay = viewport . repaint . repaint_delay,} ,  ) 
}
 )  . collect (  ) ;
if(is_last){
// Remove dead viewports:
self . viewports . retain (  | id , _ | all_viewport_ids . contains ( id )  ) ;
self . viewport_parents . retain (  | id , _ | all_viewport_ids . contains ( id )  ) ;

}
else{
const viewport_id = self . viewportId (  ) ;
self . memory . setViewportId ( viewport_id ) ;

}
const /* Ziggify: active_pixels_per_point : std :: collections :: BTreeSet < OrderedFloat < f32 > > */ =self . viewports . values (  )  . map (  | v | v . input . pixels_per_point . into (  )  )  . collect (  ) ;
self . fonts . retain (  | pixels_per_point , _ | {
if(active_pixels_per_point . contains ( pixels_per_point ) ){
true
}
else{
log . trace !  ( "Freeing Fonts with pixels_per_point={} because it is no longer needed" , pixels_per_point . intoInner (  )  ) ;
false
}

}
 ) ;
FullOutput {.platform_output = platform_output,.textures_delta = textures_delta,.shapes = shapes,.pixels_per_point = pixels_per_point,.viewport_output = viewport_output,}
}

// END: impl ContextImpl
// BEGIN: impl Context
/// Tessellate the given shapes into triangle meshes.
///
/// `pixels_per_point` is used for feathering (anti-aliasing).
/// For this you can use [`FullOutput::pixels_per_point`], [`Self::pixels_per_point`],
/// or whatever is appropriate for your viewport.
pub fn tessellate(self: Context,shapes: ArrayList(ClippedShape),pixels_per_point: f32,)ArrayList(ClippedPrimitive){
crate . profile_function !  (  ) ;
// A tempting optimization is to reuse the tessellation from last frame if the
// shapes are the same, but just comparing the shapes takes about 50% of the time
// it takes to tessellate them, so it is not a worth optimization.
self . write (  | ctx | {
const tessellation_options = ctx . memory . options . tessellation_options;
const texture_atlas = ctx . fonts . get (  & pixels_per_point . into (  )  )  . expect ( "tessellate called with a different pixels_per_point than the font atlas was created with. \nYou should use egui::FullOutput::pixels_per_point when tessellating." )  . textureAtlas (  ) ;
const /* Ziggify: ( font_tex_size , prepared_discs ) */ ={
const atlas = texture_atlas . lock (  ) ;
 ( atlas . size (  )  , atlas . preparedDiscs (  )  ) 
}
;
const paint_stats = PaintStats . fromShapes (  & shapes ) ;
const clipped_primitives = {
crate . profile_scope !  ( "tessellator::tessellate_shapes" ) ;
tessellator . Tessellator . new ( pixels_per_point , tessellation_options , font_tex_size , prepared_discs ,  )  . tessellateShapes ( shapes ) 
}
;
ctx . paint_stats = paint_stats . withClippedPrimitives (  & clipped_primitives ) ;
clipped_primitives
}
 ) 
}
// ---------------------------------------------------------------------
/// Position and size of the egui area.
pub fn screenRect(self: Context)Rect{
self . input (  | i | i . screenRect (  )  ) 
}
/// How much space is still available after panels has been added.
///
/// This is the "background" area, what egui doesn't cover with panels (but may cover with windows).
/// This is also the area to which windows are constrained.
pub fn availableRect(self: Context)Rect{
self . frameState (  | s | s . availableRect (  )  ) 
}
/// How much space is used by panels and windows.
pub fn usedRect(self: Context)Rect{
self . write (  | ctx | {
var used = ctx . viewport (  )  . frame_state . used_by_panels;
for (ctx . memory . areas (  )  . visibleWindows (  ) ) |window|{
used = used . union ( window . rect (  )  ) ;

}
used
}
 ) 
}
/// How much space is used by panels and windows.
///
/// You can shrink your egui area to this size and still fit all egui components.
pub fn usedSize(self: Context)Vec2{
self . usedRect (  )  . max - Pos2 . ZERO
}
// ---------------------------------------------------------------------
/// Is the pointer (mouse/touch) over any egui area?
pub fn isPointerOverArea(self: Context)bool{
const pointer_pos = self . input (  | i | i . pointer . interactPos (  )  ) ;
if (/* Ziggify: Some ( pointer_pos ) */ pointer_pos) {
if (/* Ziggify: Some ( layer ) */ self . layerIdAt ( pointer_pos ) ) {
if(layer . order == Order . Background){
 ! self . frameState (  | state | state . unused_rect . contains ( pointer_pos )  ) 
}
else{
true
}

}
else{
false
}

}
else{
false
}

}
/// True if egui is currently interested in the pointer (mouse or touch).
///
/// Could be the pointer is hovering over a [`Window`] or the user is dragging a widget.
/// If `false`, the pointer is outside of any egui area and so
/// you may be interested in what it is doing (e.g. controlling your game).
/// Returns `false` if a drag started outside of egui and then moved over an egui area.
pub fn wantsPointerInput(self: Context)bool{
self . isUsingPointer (  )  or  ( self . isPointerOverArea (  )  and  ! self . input (  | i | i . pointer . anyDown (  )  )  ) 
}
/// Is egui currently using the pointer position (e.g. dragging a slider)?
///
/// NOTE: this will return `false` if the pointer is just hovering over an egui area.
pub fn isUsingPointer(self: Context)bool{
self . memory (  | m | m . interaction (  )  . isUsingPointer (  )  ) 
}
/// If `true`, egui is currently listening on text input (e.g. typing text in a [`TextEdit`]).
pub fn wantsKeyboardInput(self: Context)bool{
self . memory (  | m | m . interaction (  )  . focus . focused (  )  . isSome (  )  ) 
}
/// Highlight this widget, to make it look like it is hovered, even if it isn't.
///
/// The highlight takes on frame to take effect if you call this after the widget has been fully rendered.
///
/// See also [`Response::highlight`].
pub fn highlightWidget(self: Context,id: Id)void{
self . frameStateMut (  | fs | fs . highlight_next_frame . insert ( id )  ) ;

}
/// Is an egui context menu open?
pub fn isContextMenuOpen(self: Context)bool{
self . data (  | d | {
d . get_temp .  < crate . menu . BarState >  ( menu . CONTEXT_MENU_ID_STR . into (  )  )  . mapOr ( false ,  | state | state . hasRoot (  )  ) 
}
 ) 
}

// END: impl Context
// Ergonomic methods to forward some calls often used in 'if let' without holding the borrow
// BEGIN: impl Context
/// Latest reported pointer position.
///
/// When tapping a touch screen, this will be `None`.
pub fn pointerLatestPos(self: Context)?Pos2{
self . input (  | i | i . pointer . latestPos (  )  ) 
}
/// If it is a good idea to show a tooltip, where is pointer?
pub fn pointerHoverPos(self: Context)?Pos2{
self . input (  | i | i . pointer . hoverPos (  )  ) 
}
/// If you detect a click or drag and wants to know where it happened, use this.
///
/// Latest position of the mouse, but ignoring any [`Event::PointerGone`]
/// if there were interactions this frame.
/// When tapping a touch screen, this will be the location of the touch.
pub fn pointerInteractPos(self: Context)?Pos2{
self . input (  | i | i . pointer . interactPos (  )  ) 
}
/// Calls [`InputState::multi_touch`].
pub fn multiTouch(self: Context)?MultiTouchInfo{
self . input (  | i | i . multiTouch (  )  ) 
}

// END: impl Context
// BEGIN: impl Context
/// Transform the graphics of the given layer.
///
/// This will also affect input.
///
/// This is a sticky setting, remembered from one frame to the next.
///
/// Can be used to implement pan and zoom (see relevant demo).
///
/// For a temporary transform, use [`Self::transform_layer_shapes`] instead.
pub fn setTransformLayer(self: Context,layer_id: LayerId,transform: TSTransform)void{
self . memoryMut (  | m | {
if(transform == TSTransform . IDENTITY){
m . layer_transforms . remove (  & layer_id ) 
}
else{
m . layer_transforms . insert ( layer_id , transform ) 
}

}
 ) ;

}
/// Move all the graphics at the given layer.
///
/// Is used to implement drag-and-drop preview.
///
/// This only applied to the existing graphics at the layer, not to new graphics added later.
///
/// For a persistent transform, use [`Self::set_transform_layer`] instead.
pub fn translateLayer(self: Context,layer_id: LayerId,delta: Vec2)void{
if(delta !  = Vec2 . ZERO){
const transform = emath . TSTransform . fromTranslation ( delta ) ;
self . transformLayerShapes ( layer_id , transform ) ;

}

}
/// Transform all the graphics at the given layer.
///
/// Is used to implement drag-and-drop preview.
///
/// This only applied to the existing graphics at the layer, not to new graphics added later.
///
/// For a persistent transform, use [`Self::set_transform_layer`] instead.
pub fn transformLayerShapes(self: Context,layer_id: LayerId,transform: TSTransform)void{
if(transform !  = TSTransform . IDENTITY){
self . graphicsMut (  | g | g . entry ( layer_id )  . transform ( transform )  ) ;

}

}
/// Top-most layer at the given position.
pub fn layerIdAt(self: Context,pos: Pos2)?LayerId{
self . memory (  | mem | {
mem . layerIdAt ( pos , mem . options . style . interaction . resize_grab_radius_side ) 
}
 ) 
}
/// Moves the given area to the top in its [`Order`].
///
/// [`Area`]:s and [`Window`]:s also do this automatically when being clicked on or interacted with.
pub fn moveToTop(self: Context,layer_id: LayerId)void{
self . memoryMut (  | mem | mem . areasMut (  )  . moveToTop ( layer_id )  ) ;

}
/// Retrieve the [`LayerId`] of the top level windows.
pub fn topLayerId(self: Context)?LayerId{
self . memory (  | mem | mem . areas (  )  . topLayerId ( Order . Middle )  ) 
}
/// Does the given rectangle contain the mouse pointer?
///
/// Will return false if some other area is covering the given layer.
///
/// The given rectangle is assumed to have been clipped by its parent clip rect.
///
/// See also [`Response::contains_pointer`].
pub fn rectContainsPointer(self: Context,layer_id: LayerId,rect: Rect)bool{
const rect = if (/* Ziggify: Some ( transform ) */ self . memory (  | m | m . layer_transforms . get (  & layer_id )  . cloned (  )  ) ) {
transform * rect
}
else{
rect
}
;
if( ! rect . isPositive (  ) ){
return false;

}
const pointer_pos = self . input (  | i | i . pointer . interactPos (  )  ) ;
const /* Ziggify: Some ( pointer_pos ) */ =pointer_poselse{
return false;

}
;
if( ! rect . contains ( pointer_pos ) ){
return false;

}
if(self . layerIdAt ( pointer_pos )  !  = Some ( layer_id ) ){
return false;

}
true
}
// ---------------------------------------------------------------------
/// Whether or not to debug widget layout on hover.
pub fn debugOnHover(self: Context)bool{
self . options (  | opt | opt . style . debug . debug_on_hover ) 
}
/// Turn on/off whether or not to debug widget layout on hover.
pub fn setDebugOnHover(self: Context,debug_on_hover: bool)void{
self . styleMut (  | style | style . debug . debug_on_hover = debug_on_hover ) ;

}

// END: impl Context
/// ## Animation
// BEGIN: impl Context
/// Returns a value in the range [0, 1], to indicate "how on" this thing is.
///
/// The first time called it will return `if value { 1.0 } else { 0.0 }`
/// Calling this with `value = true` will always yield a number larger than zero, quickly going towards one.
/// Calling this with `value = false` will always yield a number less than one, quickly going towards zero.
///
/// The function will call [`Self::request_repaint()`] when appropriate.
///
/// The animation time is taken from [`Style::animation_time`].
pub fn animateBool(self: Context,id: Id,value: bool)f32{
const animation_time = self . style (  )  . animation_time;
self . animateBoolWithTime ( id , value , animation_time ) 
}
/// Like [`Self::animate_bool`] but allows you to control the animation time.
pub fn animateBoolWithTime(self: Context,id: Id,target_value: bool,animation_time: f32)f32{
const animated_value = self . write (  | ctx | {
ctx . animation_manager . animateBool (  & ctx . viewports . entry ( ctx . viewportId (  )  )  . orDefault (  )  . input , animation_time , id , target_value ,  ) 
}
 ) ;
const animation_in_progress = 0.0 < animated_value and animated_value < 1.0;
if(animation_in_progress){
self . requestRepaint (  ) ;

}
animated_value
}
/// Smoothly animate an `f32` value.
///
/// At the first call the value is written to memory.
/// When it is called with a new value, it linearly interpolates to it in the given time.
pub fn animateValueWithTime(self: Context,id: Id,target_value: f32,animation_time: f32)f32{
const animated_value = self . write (  | ctx | {
ctx . animation_manager . animateValue (  & ctx . viewports . entry ( ctx . viewportId (  )  )  . orDefault (  )  . input , animation_time , id , target_value ,  ) 
}
 ) ;
const animation_in_progress = animated_value !  = target_value;
if(animation_in_progress){
self . requestRepaint (  ) ;

}
animated_value
}
/// Clear memory of any animations.
pub fn clearAnimations(self: Context)void{
self . write (  | ctx | ctx . animation_manager = Default . default (  )  ) ;

}

// END: impl Context
// BEGIN: impl Context
/// Show a ui for settings (style and tessellation options).
pub fn settingsUi(self: Context,ui: *Ui)void{
const prev_options = self . options (  | o | o . clone (  )  ) ;
var options = prev_options . clone (  ) ;
options . ui ( ui ) ;
if(options !  = prev_options){
self . optionsMut ( move | o |  * o = options ) ;

}

}
/// Show the state of egui, including its input and output.
pub fn inspectionUi(self: Context,ui: *Ui)void{
ui . label ( format !  ( "Is using pointer: {}" , self . isUsingPointer (  )  )  )  . onHoverText ( "Is egui currently using the pointer actively (e.g. dragging a slider)?" ,  ) ;
ui . label ( format !  ( "Wants pointer input: {}" , self . wantsPointerInput (  )  )  )  . onHoverText ( "Is egui currently interested in the location of the pointer (either because it is in use, or because it is hovering over a window)." ) ;
ui . label ( format !  ( "Wants keyboard input: {}" , self . wantsKeyboardInput (  )  )  )  . onHoverText ( "Is egui currently listening for text input?" ) ;
ui . label ( format !  ( "Keyboard focus widget: {}" , self . memory (  | m | m . interaction (  )  . focus . focused (  )  )  . asRef (  )  . map ( Id . short_debug_format )  . unwrapOrDefault (  )  )  )  . onHoverText ( "Is egui currently listening for text input?" ) ;
const pointer_pos = self . pointerHoverPos (  )  . mapOrElse ( String . new ,  | pos | format !  ( "{pos:?}" )  ) ;
ui . label ( format !  ( "Pointer pos: {pointer_pos}" )  ) ;
const top_layer = self . pointerHoverPos (  )  . andThen (  | pos | self . layerIdAt ( pos )  )  . mapOrElse ( String . new ,  | layer | layer . shortDebugFormat (  )  ) ;
ui . label ( format !  ( "Top layer under mouse: {top_layer}" )  ) ;
ui . addSpace ( 16.0 ) ;
ui . label ( format !  ( "There are {} text galleys in the layout cache" , self . fonts (  | f | f . numGalleysInCache (  )  )  )  )  . onHoverText ( "This is approximately the number of text strings on screen" ) ;
ui . addSpace ( 16.0 ) ;
CollapsingHeader . new ( "üîÉ Repaint Causes" )  . defaultOpen ( false )  . show ( ui ,  | ui | {
ui . setMinHeight ( 120.0 ) ;
ui . label ( "What caused egui to repaint:" ) ;
ui . addSpace ( 8.0 ) ;
const causes = ui . ctx (  )  . repaintCauses (  ) ;
for (causes) |cause|{
ui . label ( cause . toString (  )  ) ;

}

}
 ) ;
CollapsingHeader . new ( "üì• Input" )  . defaultOpen ( false )  . show ( ui ,  | ui | {
const input = ui . input (  | i | i . clone (  )  ) ;
input . ui ( ui ) ;

}
 ) ;
CollapsingHeader . new ( "üìä Paint stats" )  . defaultOpen ( false )  . show ( ui ,  | ui | {
const paint_stats = self . read (  | ctx | ctx . paint_stats ) ;
paint_stats . ui ( ui ) ;

}
 ) ;
CollapsingHeader . new ( "üñº Textures" )  . defaultOpen ( false )  . show ( ui ,  | ui | {
self . textureUi ( ui ) ;

}
 ) ;
CollapsingHeader . new ( "üî† Font texture" )  . defaultOpen ( false )  . show ( ui ,  | ui | {
const font_image_size = self . fonts (  | f | f . fontImageSize (  )  ) ;
crate . introspection . fontTextureUi ( ui , font_image_size ) ;

}
 ) ;
CollapsingHeader . new ( "Label text selection state" )  . defaultOpen ( false )  . show ( ui ,  | ui | {
ui . label ( format !  ( "{:#?}" , crate . text_selection . LabelSelectionState . load ( ui . ctx (  )  )  )  ) ;

}
 ) ;
CollapsingHeader . new ( "Interaction" )  . defaultOpen ( false )  . show ( ui ,  | ui | {
const interact_widgets = self . write (  | ctx | ctx . viewport (  )  . interact_widgets . clone (  )  ) ;
interact_widgets . ui ( ui ) ;

}
 ) ;

}
/// Show stats about the allocated textures.
pub fn textureUi(self: Context,ui: *crate.Ui)void{
const tex_mngr = self . texManager (  ) ;
const tex_mngr = tex_mngr . read (  ) ;
const /* Ziggify: mut textures : Vec < _ > */ =tex_mngr . allocated (  )  . collect (  ) ;
textures . sortByKey (  |  ( id , _ )  |  * id ) ;
var bytes = 0;
for ( & textures) |/* Ziggify: (tex, _) */|{
bytes +  = tex . bytesUsed (  ) ;

}
ui . label ( format !  ( "{} allocated texture(s), using {:.1} MB" , textures . len (  )  , bytes as f64 * 1e-6 )  ) ;
const max_preview_size = vec2 ( 48.0 , 32.0 ) ;
ui . group (  | ui | {
ScrollArea . vertical (  )  . maxHeight ( 300.0 )  . autoShrink ( [false , true] )  . show ( ui ,  | ui | {
ui . styleMut (  )  . override_text_style = Some ( TextStyle . Monospace ) ;
Grid . new ( "textures" )  . striped ( true )  . numColumns ( 4 )  . spacing ( vec2 ( 16.0 , 2.0 )  )  . minRowHeight ( max_preview_size . y )  . show ( ui ,  | ui | {
for (textures) |/* Ziggify: ( & texture_id , meta )*/|{
const /* Ziggify: [ w , h ] */ =meta . size;
var size = vec2 ( w as f32 , h as f32 ) ;
size *  =  ( max_preview_size . x / size . x )  . min ( 1.0 ) ;
size *  =  ( max_preview_size . y / size . y )  . min ( 1.0 ) ;
ui . image ( SizedTexture . new ( texture_id , size )  )  . onHoverUi (  | ui | {
// show larger on hover
const max_size = 0.5 * ui . ctx (  )  . screenRect (  )  . size (  ) ;
var size = vec2 ( w as f32 , h as f32 ) ;
size *  = max_size . x / size . x . max ( max_size . x ) ;
size *  = max_size . y / size . y . max ( max_size . y ) ;
ui . image ( SizedTexture . new ( texture_id , size )  ) ;

}
 ) ;
ui . label ( format !  ( "{w} x {h}" )  ) ;
ui . label ( format !  ( "{:.3} MB" , meta . bytesUsed (  )  as f64 * 1e-6 )  ) ;
ui . label ( format !  ( "{:?}" , meta . name )  ) ;
ui . endRow (  ) ;

}

}
 ) ;

}
 ) ;

}
 ) ;

}
/// Shows the contents of [`Self::memory`].
pub fn memoryUi(self: Context,ui: *crate.Ui)void{
if(ui . button ( "Reset all" )  . onHoverText ( "Reset all egui state" )  . clicked (  ) ){
self . memoryMut (  | mem |  * mem = Default . default (  )  ) ;

}
const /* Ziggify: ( num_state , num_serialized ) */ =self . data (  | d |  ( d . len (  )  , d . countSerialized (  )  )  ) ;
ui . label ( format !  ( "{num_state} widget states stored (of which {num_serialized} are serialized)." )  ) ;
ui . horizontal (  | ui | {
ui . label ( format !  ( "{} areas (panels, windows, popups, ‚Ä¶)" , self . memory (  | mem | mem . areas (  )  . count (  )  )  )  ) ;
if(ui . button ( "Reset" )  . clicked (  ) ){
self . memoryMut (  | mem |  * mem . areasMut (  )  = Default . default (  )  ) ;

}

}
 ) ;
ui . indent ( "areas" ,  | ui | {
ui . label ( "Visible areas, ordered back to front." ) ;
ui . label ( "Hover to highlight" ) ;
const /* Ziggify: layers_ids : Vec < LayerId > */ =self . memory (  | mem | mem . areas (  )  . order (  )  . toVec (  )  ) ;
for (layers_ids) |layer_id|{
const area = self . memory (  | mem | mem . areas (  )  . get ( layer_id . id )  . copied (  )  ) ;
if (/* Ziggify: Some ( area ) */ area) {
const is_visible = self . memory (  | mem | mem . areas (  )  . isVisible (  & layer_id )  ) ;
if( ! is_visible){
continue;

}
const text = format !  ( "{} - {:?}" , layer_id . shortDebugFormat (  )  , area . rect (  )  ,  ) ;
// TODO(emilk): `Sense::hover_highlight()`
if(ui . add ( Label . new ( RichText . new ( text )  . monospace (  )  )  . sense ( Sense . click (  )  )  )  . hovered and is_visible){
ui . ctx (  )  . debugPainter (  )  . debugRect ( area . rect (  )  , Color32 . RED , "" ) ;

}

}

}

}
 ) ;
ui . horizontal (  | ui | {
ui . label ( format !  ( "{} collapsing headers" , self . data (  | d | d . count .  < containers . collapsing_header . InnerState >  (  )  )  )  ) ;
if(ui . button ( "Reset" )  . clicked (  ) ){
self . dataMut (  | d | d . remove_by_type .  < containers . collapsing_header . InnerState >  (  )  ) ;

}

}
 ) ;
ui . horizontal (  | ui | {
ui . label ( format !  ( "{} menu bars" , self . data (  | d | d . count .  < menu . BarState >  (  )  )  )  ) ;
if(ui . button ( "Reset" )  . clicked (  ) ){
self . dataMut (  | d | d . remove_by_type .  < menu . BarState >  (  )  ) ;

}

}
 ) ;
ui . horizontal (  | ui | {
ui . label ( format !  ( "{} scroll areas" , self . data (  | d | d . count .  < scroll_area . State >  (  )  )  )  ) ;
if(ui . button ( "Reset" )  . clicked (  ) ){
self . dataMut (  | d | d . remove_by_type .  < scroll_area . State >  (  )  ) ;

}

}
 ) ;
ui . horizontal (  | ui | {
ui . label ( format !  ( "{} resize areas" , self . data (  | d | d . count .  < resize . State >  (  )  )  )  ) ;
if(ui . button ( "Reset" )  . clicked (  ) ){
self . dataMut (  | d | d . remove_by_type .  < resize . State >  (  )  ) ;

}

}
 ) ;
ui . shrinkWidthToCurrent (  ) ;// don't let the text below grow this window wider
ui . label ( "NOTE: the position of this window cannot be reset from within itself." ) ;
ui . collapsing ( "Interaction" ,  | ui | {
const interaction = self . memory (  | mem | mem . interaction (  )  . clone (  )  ) ;
interaction . ui ( ui ) ;

}
 ) ;

}

// END: impl Context
// BEGIN: impl Context
/// Edit the active [`Style`].
pub fn styleUi(self: Context,ui: *Ui)void{
const /* Ziggify: mut style : Style */ = (  * self . style (  )  )  . clone (  ) ;
style . ui ( ui ) ;
self . setStyle ( style ) ;

}

// END: impl Context
/// ## Accessibility
// BEGIN: impl Context
/// Call the provided function with the given ID pushed on the stack of
/// parent IDs for accessibility purposes. If the `accesskit` feature
/// is disabled or if AccessKit support is not active for this frame,
/// the function is still called, but with no other effect.
///
/// No locks are held while the given closure is called.
pub fn withAccessibilityParent(self: Context,_id: Id,f: /* Ziggify:  impl FnOnce()*/)void{
// TODO(emilk): this isn't thread-safe - another thread can call this function between the push/pop calls
self . frameStateMut (  | fs | {
if (/* Ziggify: Some ( state ) */ fs . accesskit_state . asMut (  ) ) {
state . parent_stack . push ( _id ) ;

}

}
 ) ;
f (  ) ;
self . frameStateMut (  | fs | {
if (/* Ziggify: Some ( state ) */ fs . accesskit_state . asMut (  ) ) {
assert_eq !  ( state . parent_stack . pop (  )  , Some ( _id )  ) ;

}

}
 ) ;

}
/// If AccessKit support is active for the current frame, get or create
/// a node builder with the specified ID and return a mutable reference to it.
/// For newly created nodes, the parent is the node with the ID at the top
/// of the stack managed by [`Context::with_accessibility_parent`].
///
/// The `Context` lock is held while the given closure is called!
///
/// Returns `None` if acesskit is off.
// TODO: consider making both RO and RW versions
pub fn accesskitNodeBuilder /* < R > */ (self: Context,id: Id,writer: /* Ziggify:  impl FnOnce( & mut accesskit :: NodeBuilder) -> R*/,)?R{
self . write (  | ctx | {
ctx . viewport (  )  . frame_state . accesskit_state . isSome (  )  . then (  or ctx . accesskitNodeBuilder ( id )  )  . map ( writer ) 
}
 ) 
}
/// Enable generation of AccessKit tree updates in all future frames.
///
/// If it's practical for the egui integration to immediately run the egui
/// application when it is either initializing the AccessKit adapter or
/// being called by the AccessKit adapter to provide the initial tree update,
/// then it should do so, to provide a complete AccessKit tree to the adapter
/// immediately. Otherwise, it should enqueue a repaint and use the
/// placeholder tree update from [`Context::accesskit_placeholder_tree_update`]
/// in the meantime.
pub fn enableAccesskit(self: Context)void{
self . write (  | ctx | ctx . is_accesskit_enabled = true ) ;

}
/// Return a tree update that the egui integration should provide to the
/// AccessKit adapter if it cannot immediately run the egui application
/// to get a full tree update after running [`Context::enable_accesskit`].
pub fn accesskitPlaceholderTreeUpdate(self: Context)accesskit.TreeUpdate{
crate . profile_function !  (  ) ;
const root_id = crate . accesskitRootId (  )  . accesskitId (  ) ;
self . write (  | ctx | TreeUpdate {.nodes = vec ! [ ( root_id , NodeBuilder . new ( Role . Window )  . build ( &ctx . accesskit_node_classes )  ,  ) ],.tree = Some ( Tree . new ( root_id )  ) ,.focus = root_id,} ) 
}

// END: impl Context
/// ## Image loading
// BEGIN: impl Context
/// Associate some static bytes with a `uri`.
///
/// The same `uri` may be passed to [`Ui::image`] later to load the bytes as an image.
///
/// By convention, the `uri` should start with `bytes://`.
/// Following that convention will lead to better error messages.
pub fn includeBytes(self: Context,uri: /* Ziggify:  Cow< ' static , str>*/,bytes: Bytes)void{
self . loaders (  )  . include . insert ( uri , bytes ) ;

}
/// Returns `true` if the chain of bytes, image, or texture loaders
/// contains a loader with the given `id`.
pub fn isLoaderInstalled(self: Context,id: str)bool{
const loaders = self . loaders (  ) ;
loaders . bytes . lock (  )  . iter (  )  . any (  | l | l . id (  )  == id )  or loaders . image . lock (  )  . iter (  )  . any (  | l | l . id (  )  == id )  or loaders . texture . lock (  )  . iter (  )  . any (  | l | l . id (  )  == id ) 
}
/// Add a new bytes loader.
///
/// It will be tried first, before any already installed loaders.
///
/// See [`load`] for more information.
pub fn addBytesLoader(self: Context,loader: /* Ziggify:  Arc< dyn load :: BytesLoader + Send + Sync + ' static>*/)void{
self . loaders (  )  . bytes . lock (  )  . push ( loader ) ;

}
/// Add a new image loader.
///
/// It will be tried first, before any already installed loaders.
///
/// See [`load`] for more information.
pub fn addImageLoader(self: Context,loader: /* Ziggify:  Arc< dyn load :: ImageLoader + Send + Sync + ' static>*/)void{
self . loaders (  )  . image . lock (  )  . push ( loader ) ;

}
/// Add a new texture loader.
///
/// It will be tried first, before any already installed loaders.
///
/// See [`load`] for more information.
pub fn addTextureLoader(self: Context,loader: /* Ziggify:  Arc< dyn load :: TextureLoader + Send + Sync + ' static>*/)void{
self . loaders (  )  . texture . lock (  )  . push ( loader ) ;

}
/// Release all memory and textures related to the given image URI.
///
/// If you attempt to load the image again, it will be reloaded from scratch.
pub fn forgetImage(self: Context,uri: str)void{
crate . profile_function !  (  ) ;
const loaders = self . loaders (  ) ;
loaders . include . forget ( uri ) ;
for (loaders . bytes . lock (  )  . iter (  ) ) |loader|{
loader . forget ( uri ) ;

}
for (loaders . image . lock (  )  . iter (  ) ) |loader|{
loader . forget ( uri ) ;

}
for (loaders . texture . lock (  )  . iter (  ) ) |loader|{
loader . forget ( uri ) ;

}

}
/// Release all memory and textures related to images used in [`Ui::image`] or [`Image`].
///
/// If you attempt to load any images again, they will be reloaded from scratch.
pub fn forgetAllImages(self: Context)void{
crate . profile_function !  (  ) ;
const loaders = self . loaders (  ) ;
loaders . include . forgetAll (  ) ;
for (loaders . bytes . lock (  )  . iter (  ) ) |loader|{
loader . forgetAll (  ) ;

}
for (loaders . image . lock (  )  . iter (  ) ) |loader|{
loader . forgetAll (  ) ;

}
for (loaders . texture . lock (  )  . iter (  ) ) |loader|{
loader . forgetAll (  ) ;

}

}
/// Try loading the bytes from the given uri using any available bytes loaders.
///
/// Loaders are expected to cache results, so that this call is immediate-mode safe.
///
/// This calls the loaders one by one in the order in which they were registered.
/// If a loader returns [`LoadError::NotSupported`][not_supported],
/// then the next loader is called. This process repeats until all loaders have
/// been exhausted, at which point this returns [`LoadError::NotSupported`][not_supported].
///
/// # Errors
/// This may fail with:
/// - [`LoadError::NotSupported`][not_supported] if none of the registered loaders support loading the given `uri`.
/// - [`LoadError::Loading`][custom] if one of the loaders _does_ support loading the `uri`, but the loading process failed.
///
/// ‚ö† May deadlock if called from within a `BytesLoader`!
///
/// [not_supported]: crate::load::LoadError::NotSupported
/// [custom]: crate::load::LoadError::Loading
pub fn tryLoadBytes(self: Context,uri: str)load.BytesLoadResult{
crate . profile_function !  ( uri ) ;
const loaders = self . loaders (  ) ;
const bytes_loaders = loaders . bytes . lock (  ) ;
// Try most recently added loaders first (hence `.rev()`)
for (bytes_loaders . iter (  )  . rev (  ) ) |loader|{
switch (loader . load ( self , uri ) ){
/* Ziggify: Err ( load :: LoadError :: NotSupported ) */=>continue,
/* Ziggify: result */=>return result,

}

}
Err ( load . LoadError . NoMatchingBytesLoader ) 
}
/// Try loading the image from the given uri using any available image loaders.
///
/// Loaders are expected to cache results, so that this call is immediate-mode safe.
///
/// This calls the loaders one by one in the order in which they were registered.
/// If a loader returns [`LoadError::NotSupported`][not_supported],
/// then the next loader is called. This process repeats until all loaders have
/// been exhausted, at which point this returns [`LoadError::NotSupported`][not_supported].
///
/// # Errors
/// This may fail with:
/// - [`LoadError::NoImageLoaders`][no_image_loaders] if tbere are no registered image loaders.
/// - [`LoadError::NotSupported`][not_supported] if none of the registered loaders support loading the given `uri`.
/// - [`LoadError::Loading`][custom] if one of the loaders _does_ support loading the `uri`, but the loading process failed.
///
/// ‚ö† May deadlock if called from within an `ImageLoader`!
///
/// [no_image_loaders]: crate::load::LoadError::NoImageLoaders
/// [not_supported]: crate::load::LoadError::NotSupported
/// [custom]: crate::load::LoadError::Loading
pub fn tryLoadImage(self: Context,uri: str,size_hint: load.SizeHint)load.ImageLoadResult{
crate . profile_function !  ( uri ) ;
const loaders = self . loaders (  ) ;
const image_loaders = loaders . image . lock (  ) ;
if(image_loaders . isEmpty (  ) ){
return Err ( load . LoadError . NoImageLoaders ) ;

}
// Try most recently added loaders first (hence `.rev()`)
for (image_loaders . iter (  )  . rev (  ) ) |loader|{
switch (loader . load ( self , uri , size_hint ) ){
/* Ziggify: Err ( load :: LoadError :: NotSupported ) */=>continue,
/* Ziggify: result */=>return result,

}

}
Err ( load . LoadError . NoMatchingImageLoader ) 
}
/// Try loading the texture from the given uri using any available texture loaders.
///
/// Loaders are expected to cache results, so that this call is immediate-mode safe.
///
/// This calls the loaders one by one in the order in which they were registered.
/// If a loader returns [`LoadError::NotSupported`][not_supported],
/// then the next loader is called. This process repeats until all loaders have
/// been exhausted, at which point this returns [`LoadError::NotSupported`][not_supported].
///
/// # Errors
/// This may fail with:
/// - [`LoadError::NotSupported`][not_supported] if none of the registered loaders support loading the given `uri`.
/// - [`LoadError::Loading`][custom] if one of the loaders _does_ support loading the `uri`, but the loading process failed.
///
/// ‚ö† May deadlock if called from within a `TextureLoader`!
///
/// [not_supported]: crate::load::LoadError::NotSupported
/// [custom]: crate::load::LoadError::Loading
pub fn tryLoadTexture(self: Context,uri: str,texture_options: TextureOptions,size_hint: load.SizeHint,)load.TextureLoadResult{
crate . profile_function !  ( uri ) ;
const loaders = self . loaders (  ) ;
const texture_loaders = loaders . texture . lock (  ) ;
// Try most recently added loaders first (hence `.rev()`)
for (texture_loaders . iter (  )  . rev (  ) ) |loader|{
switch (loader . load ( self , uri , texture_options , size_hint ) ){
/* Ziggify: Err ( load :: LoadError :: NotSupported ) */=>continue,
/* Ziggify: result */=>return result,

}

}
Err ( load . LoadError . NoMatchingTextureLoader ) 
}
/// The loaders of bytes, images, and textures.
pub fn loaders(self: Context)/* Ziggify:  Arc< Loaders>*/{
crate . profile_function !  (  ) ;
self . read (  | this | this . loaders . clone (  )  ) 
}

// END: impl Context
/// ## Viewports
// BEGIN: impl Context
/// Return the `ViewportId` of the current viewport.
///
/// If this is the root viewport, this will return [`ViewportId::ROOT`].
///
/// Don't use this outside of `Self::run`, or after `Self::end_frame`.
pub fn viewportId(self: Context)ViewportId{
self . read (  | ctx | ctx . viewportId (  )  ) 
}
/// Return the `ViewportId` of his parent.
///
/// If this is the root viewport, this will return [`ViewportId::ROOT`].
///
/// Don't use this outside of `Self::run`, or after `Self::end_frame`.
pub fn parentViewportId(self: Context)ViewportId{
self . read (  | ctx | ctx . parentViewportId (  )  ) 
}
/// For integrations: Set this to render a sync viewport.
///
/// This will only set the callback for the current thread,
/// which most likely should be the main thread.
///
/// When an immediate viewport is created with [`Self::show_viewport_immediate`] it will be rendered by this function.
///
/// When called, the integration needs to:
/// * Check if there already is a window for this viewport id, and if not open one
/// * Set the window attributes (position, size, ‚Ä¶) based on [`ImmediateViewport::builder`].
/// * Call [`Context::run`] with [`ImmediateViewport::viewport_ui_cb`].
/// * Handle the output from [`Context::run`], including rendering
pub fn setImmediateViewportRenderer(callback: /* Ziggify:  impl for< ' a> Fn( & Self , ImmediateViewport< ' a>) + ' static*/,)void{
const callback = Box . new ( callback ) ;
IMMEDIATE_VIEWPORT_RENDERER . with (  | render_sync | {
render_sync . replace ( Some ( callback )  ) ;

}
 ) ;

}
/// If `true`, [`Self::show_viewport_deferred`] and [`Self::show_viewport_immediate`] will
/// embed the new viewports inside the existing one, instead of spawning a new native window.
///
/// `eframe` sets this to `false` on supported platforms, but the default value is `true`.
pub fn embedViewports(self: Context)bool{
self . read (  | ctx | ctx . embed_viewports ) 
}
/// If `true`, [`Self::show_viewport_deferred`] and [`Self::show_viewport_immediate`] will
/// embed the new viewports inside the existing one, instead of spawning a new native window.
///
/// `eframe` sets this to `false` on supported platforms, but the default value is `true`.
pub fn setEmbedViewports(self: Context,value: bool)void{
self . write (  | ctx | ctx . embed_viewports = value ) ;

}
/// Send a command to the current viewport.
///
/// This lets you affect the current viewport, e.g. resizing the window.
pub fn sendViewportCmd(self: Context,command: ViewportCommand)void{
self . sendViewportCmdTo ( self . viewportId (  )  , command ) ;

}
/// Send a command to a specific viewport.
///
/// This lets you affect another viewport, e.g. resizing its window.
pub fn sendViewportCmdTo(self: Context,id: ViewportId,command: ViewportCommand)void{
self . requestRepaintOf ( id ) ;
if(command . requiresParentRepaint (  ) ){
self . requestRepaintOf ( self . parentViewportId (  )  ) ;

}
self . write (  | ctx | ctx . viewportFor ( id )  . commands . push ( command )  ) ;

}
/// Show a deferred viewport, creating a new native window, if possible.
///
/// The given id must be unique for each viewport.
///
/// You need to call this each frame when the child viewport should exist.
///
/// You can check if the user wants to close the viewport by checking the
/// [`crate::ViewportInfo::close_requested`] flags found in [`crate::InputState::viewport`].
///
/// The given callback will be called whenever the child viewport needs repainting,
/// e.g. on an event or when [`Self::request_repaint`] is called.
/// This means it may be called multiple times, for instance while the
/// parent viewport (the caller) is sleeping but the child viewport is animating.
///
/// You will need to wrap your viewport state in an `Arc<RwLock<T>>` or `Arc<Mutex<T>>`.
/// When this is called again with the same id in `ViewportBuilder` the render function for that viewport will be updated.
///
/// You can also use [`Self::show_viewport_immediate`], which uses a simpler `FnOnce`
/// with no need for `Send` or `Sync`. The downside is that it will require
/// the parent viewport (the caller) to repaint anytime the child is repainted,
/// and vice versa.
///
/// If [`Context::embed_viewports`] is `true` (e.g. if the current egui
/// backend does not support multiple viewports), the given callback
/// will be called immediately, embedding the new viewport in the current one.
/// You can check this with the [`ViewportClass`] given in the callback.
/// If you find [`ViewportClass::Embedded`], you need to create a new [`crate::Window`] for you content.
///
/// See [`crate::viewport`] for more information about viewports.
pub fn showViewportDeferred(self: Context,new_viewport_id: ViewportId,viewport_builder: ViewportBuilder,viewport_ui_cb: /* Ziggify:  impl Fn( & Self , ViewportClass) + Send + Sync + ' static*/,)void{
crate . profile_function !  (  ) ;
if(self . embedViewports (  ) ){
viewportUiCb ( self , ViewportClass . Embedded ) ;

}
else{
self . write (  | ctx | {
ctx . viewport_parents . insert ( new_viewport_id , ctx . viewportId (  )  ) ;
const viewport = ctx . viewports . entry ( new_viewport_id )  . orDefault (  ) ;
viewport . class = ViewportClass . Deferred;
viewport . builder = viewport_builder;
viewport . used = true;
viewport . viewport_ui_cb = Some ( Arc . new ( move | ctx | {
 ( viewport_ui_cb )  ( ctx , ViewportClass . Deferred ) ;

}
 )  ) ;

}
 ) ;

}

}
/// Show an immediate viewport, creating a new native window, if possible.
///
/// This is the easier type of viewport to use, but it is less performant
/// at it requires both parent and child to repaint if any one of them needs repainting,
/// which efficvely produce double work for two viewports, and triple work for three viewports, etc.
/// To avoid this, use [`Self::show_viewport_deferred`] instead.
///
/// The given id must be unique for each viewport.
///
/// You need to call this each frame when the child viewport should exist.
///
/// You can check if the user wants to close the viewport by checking the
/// [`crate::ViewportInfo::close_requested`] flags found in [`crate::InputState::viewport`].
///
/// The given ui function will be called immediately.
/// This may only be called on the main thread.
/// This call will pause the current viewport and render the child viewport in its own window.
/// This means that the child viewport will not be repainted when the parent viewport is repainted, and vice versa.
///
/// If [`Context::embed_viewports`] is `true` (e.g. if the current egui
/// backend does not support multiple viewports), the given callback
/// will be called immediately, embedding the new viewport in the current one.
/// You can check this with the [`ViewportClass`] given in the callback.
/// If you find [`ViewportClass::Embedded`], you need to create a new [`crate::Window`] for you content.
///
/// See [`crate::viewport`] for more information about viewports.
pub fn showViewportImmediate /* < T > */ (self: Context,new_viewport_id: ViewportId,builder: ViewportBuilder,viewport_ui_cb: /* Ziggify:  impl FnOnce( & Self , ViewportClass) -> T*/,)T{
crate . profile_function !  (  ) ;
if(self . embedViewports (  ) ){
return viewportUiCb ( self , ViewportClass . Embedded ) ;

}
IMMEDIATE_VIEWPORT_RENDERER . with (  | immediate_viewport_renderer | {
const immediate_viewport_renderer = immediate_viewport_renderer . borrow (  ) ;
const /* Ziggify: Some ( immediate_viewport_renderer ) */ =immediate_viewport_renderer . asRef (  ) else{
// This egui backend does not support multiple viewports.
return viewportUiCb ( self , ViewportClass . Embedded ) ;

}
;
const ids = self . write (  | ctx | {
const parent_viewport_id = ctx . viewportId (  ) ;
ctx . viewport_parents . insert ( new_viewport_id , parent_viewport_id ) ;
const viewport = ctx . viewports . entry ( new_viewport_id )  . orDefault (  ) ;
viewport . builder = builder . clone (  ) ;
viewport . used = true;
viewport . viewport_ui_cb = None;// it is immediate
ViewportIdPair . fromSelfAndParent ( new_viewport_id , parent_viewport_id ) 
}
 ) ;
var out = None;
{
const out = &out;
const viewport = ImmediateViewport {.ids = ids,.builder = builder,.viewport_ui_cb = Box . new ( move | context | {
 * out = Some ( viewportUiCb ( context , ViewportClass . Immediate )  ) ;

}
 ) ,};
immediateViewportRenderer ( self , viewport ) ;

}
out . expect ( "egui backend is implemented incorrectly - the user callback was never called" ,  ) 
}
 ) 
}

// END: impl Context
/// ## Interaction
// BEGIN: impl Context
/// Read you what widgets are currently being interacted with.
pub fn interactionSnapshot /* < R > */ (self: Context,reader: /* Ziggify:  impl FnOnce( & InteractionSnapshot) -> R*/)R{
self . write (  | w | reader (  & w . viewport (  )  . interact_widgets )  ) 
}
/// The widget currently being dragged, if any.
///
/// For widgets that sense both clicks and drags, this will
/// not be set until the mouse cursor has moved a certain distance.
///
/// NOTE: if the widget was released this frame, this will be `None`.
/// Use [`Self::drag_stopped_id`] instead.
pub fn draggedId(self: Context)?Id{
self . interactionSnapshot (  | i | i . dragged ) 
}
/// Is this specific widget being dragged?
///
/// A widget that sense both clicks and drags is only marked as "dragged"
/// when the mouse has moved a bit
///
/// See also: [`crate::Response::dragged`].
pub fn isBeingDragged(self: Context,id: Id)bool{
self . draggedId (  )  == Some ( id ) 
}
/// This widget just started being dragged this frame.
///
/// The same widget should also be found in [`Self::dragged_id`].
pub fn dragStartedId(self: Context)?Id{
self . interactionSnapshot (  | i | i . drag_started ) 
}
/// This widget was being dragged, but was released this frame
pub fn dragStoppedId(self: Context)?Id{
self . interactionSnapshot (  | i | i . drag_stopped ) 
}
/// Set which widget is being dragged.
pub fn setDraggedId(self: Context,id: Id)void{
self . write (  | ctx | {
const vp = ctx . viewport (  ) ;
const i = &vp . interact_widgets;
if(i . dragged !  = Some ( id ) ){
i . drag_stopped = i . dragged . or ( i . drag_stopped ) ;
i . dragged = Some ( id ) ;
i . drag_started = Some ( id ) ;

}
ctx . memory . interactionMut (  )  . potential_drag_id = Some ( id ) ;

}
 ) ;

}
/// Stop dragging any widget.
pub fn stopDragging(self: Context)void{
self . write (  | ctx | {
const vp = ctx . viewport (  ) ;
const i = &vp . interact_widgets;
if(i . dragged . isSome (  ) ){
i . drag_stopped = i . dragged;
i . dragged = None;

}
ctx . memory . interactionMut (  )  . potential_drag_id = None;

}
 ) ;

}
/// Is something else being dragged?
///
/// Returns true if we are dragging something, but not the given widget.
pub fn draggingSomethingElse(self: Context,not_this: Id)bool{
const dragged = self . draggedId (  ) ;
dragged . isSome (  )  and dragged !  = Some ( not_this ) 
}

// END: impl Context
fn contextImplSendSync()void{
// Ziffigy: fn assert_send_sync < T : Send + Sync > ( ) { }
assert_send_sync .  < Context >  (  ) ;

}
